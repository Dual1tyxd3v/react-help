/* eslint-disable quotes */
const Javascript = [
  [
    `.focus()`,
    `Метод элемента который устанавливает фокус на этом элементе`
  ],
  [
    `.isNaN(x)`,
    `Метод объекта Number для проверки переменной x на значение NaN. По скольку NaN ничему не равно даже самому себе то это единственная проверка`
  ],
  [
    `history.pushState(x, y, z)`,
    `Метод объекта истории браузера позволяет добавить в историю браузера новую точку входа делая ее последней без перезагрузки страницы, где:<br>
    --x - данные состояния истории для обработчика события popstate (можно оставить null)<br>
    --y - заголовок для отображения в браузере (можно оставить '')<br>
    --z - URL для отображения в адресной строке. Если задан относительный путь то он просто будет добавлен в конец адреса, также можно задать полный путь`
  ],
  [
    `a.contains(b)`,
    `Метод node объекта позволяет проверить находится ли элемент b внутри элемента a`
  ],
  [
    `window.matchMedia(x)`,
    `Метод глобального объекта позволющий взаимодействовать с медиавыражениями, где х - строка с медиа выражением`
  ],
  [
    `Методы перебора массива`,
    `1. По скорости методы for и for/in быстрее потому что в первую очередь получают доступ к элементу по индексу<br>
    2. Перебор массива с нечисловыми именами свойств. В случае если у массива имеется ненаследуемое свойство с нечисловым ключом то перебор с помощью for/in также его покажет, что считается плохой практикой<br>
    3. Перебор массива с пустыми элементами. for и for/of перебирают все элементы в то время как foreach и for/in только со значениями<br>
    4. В случае если необходимо выполнить асинхронный код в цикле foreach работает не совсем корректно<br>
    5. В цикле for/of нет доступа к индексу напрямую. Вместо этого приходится усложнять конструкцию - <b>for (const [index, element] of arr.entries()) {}</b><br>
    6. foreach позволяет использовать цепочки вызовов`
  ],
  [
    `Оператор логического присваивания`,
    `Это короткая запись присваивания значения с применением условия<br>
    <b>someObject.some ??= 100</b> - такая запись аналогична - someObject.some = someObject.some ?? 100. Сначала проверяет на null/undefined текущее значение и если это так присваивает новое.
    <b>||=</b> - аналогичная запись но с оператором или<br>
    <b>&&=</b> - аналог записи - x.a = x.a && 100 но с 1 различием. Во 2 варианте если текущего св-ва не существует то оно получит значение undefined, но в 1 случае запись просто не произойдет и данное св-во не будет добавлено`
  ],
  [
    `Структуры данных`,
    `<b>Связный список</b><br>
    <img class="" src="./img/list2.png"><br>
    <img class="" src="./img/list.png"><br>
    Структура данных состоящая из узлов каждый из которых содержит данные и ссылку на соседние узлы, последовательно связанные друг с другом. На картинках представлен обычный связный список и двусвязный список<br>
    + более гибкий чем массив. Позволяет быстрее добавлять/удалять элементы O(1)<br>
    + в отличии от массива имеет динамический размер<br>
    - нет прямого доступа к элементам, приходится делать полный перебор (O(n))<hr>
    <b>Стек</b><br>
    Упорядоченная коллекция элементов где добавление и удаление происходит всегда с 1 стороны. Работает по принципу последний зашел первый вышел<hr>
    <b>Очередь</b><br>
    Упорядоченная коллекция элементов которая работает по принципу первый зашел первый вышел<hr>
    <b>Множества</b><br>
    Уникальный набор элементов идущих в порядке их добавления. В JS это осуществляет Set. Он работает на основе хэш ф-ций на основе значений а потому все операции кроме перебора коллекции займут О(1)<hr>
    <b>Map</b><br>
    Коллекция которая хранит данные в виде ключ/значение. Похож на объект но разница в том что ключем может быть не только строка а любой примитив. Также Map хранит тип ключа поэтому '1' и 1 будут двумя разными ключами. Map использует хэш ф-ции уже на основе ключей поэтому работает быстро<hr>
    <b>Хэш таблица</b><br>
    <img src="./img/hash.png"><br>
    Это структура данных которая хранит данные в виде ключ/значение, но доступ к значению возможен только по индексу созданному специальной хэш ф-цией. В случае если для двух разных элементов создается один индекс(коллизия) проблема решается 2 способами:<br>
    1) вместо значения по хэш ключу будет хранится список с ключом/значением элементов сгенерировавших коллизию<br>
    2) метод открытой адресации. В случае если индекс уже занят происходит поиск первого свободного индекса но этот подход ресурсоемкий в случае если таблица большая<br>
    По сравнению с массивом поиск и вставка элементов в хэш таблице происходит быстрее<br>
    Самый простой способ получения хэша брать ключ в виде строки, получать его код с помощью .charAtCode() и получать остаток от деления на длину массива. В случае коллизии записать значение в виде списка где будут хранится ключ и значение. Также можно прибегнуть к рехэшированию - в случае коллизии число на которое делится полученный код увеличивается и идет перерасчет всей таблицы заного<hr>
    <b>Бинарное дерево</b><br>
    <img src="./img/bin_tree.png"><br>
    Это структура которая хранит данные в виде узлов. Каждый узел хранит значение а также может иметь не более 2 потомков. При этом левый потомок обязательно меньше родителя а правый больше. Такая структура позволяет очень быстро производить поиск/вставку/удаление элементов<hr>
    <b>Сбалансированное дерево</b><br>
    Тоже что и бинарное дерево, но избавляет нас от проблемы когда дерево превращается в последовательную структура данных. Есть 2 варианта балансировки:<br>
    1) красно-черное дерево<br>
    2) AVL дерево - когда у каждого узла левое и правое поддерево отличается по высоте не более чем на 1. В случае удалении или вставки элемента вызывается специальная ф-ция компоратор которая выравнивает дерево<hr>
    <b>Префиксное дерево</b><br>
    <img src="./img/prefix_tree.png"><br>
    Это структура которая хранит данные в виде последовательно связанных узлов. Где первый узел является пустым литералом а каждый последующий хранит буквенный литерал и метку (boolean) указывающую на то является ли слово законченным. Такая структура хорошо подходит для автозаполнения<hr>
    <b>Бинарная куча</b><br>
    <img src="./img/bin_heap.png"><br>
    Структура данных напоминает бинарное дерево но имеет свои особенности:<br>
    1) Максимальная куча - когда верхний узел является самым большим элементом а его потомки должны быть меньше него, при этом больший потомок распологается слева а меньший справа НО последний уровень заполняется наоборот (меньший слева больший справа)<br>
    2) Минимальная куча - верхний узел хранит наименьшее значение, все потомки больше своего родителя. Наибольший потомок становится справа наименьший слева. В случае последнего ряда наибольший слева наименьший справа<hr>
    <b>Граф</b><br>
    <img src="./img/graf.png"><br>
    Нелинейная структура данных которая помимо значений хранит также связи между разными объектами. Граф может быть неориентированный и ориентированный(объект учитывает направление ребер)<br>
    <img src="./img/graf_weighted.png"><br>
    Также граф может быть взвешенным, это значит что также учитывается вес ребра его объектов<br>
    Если вершина графа не связана с другими она считается изолированной<br>
    Перебор графа осуществляется в глубину или в ширину. При переборе стоит учитывать пройденные узлы и определять их куда то например в стек. После перебора всех связных узлов стоить не забыть проверить изолированные узлы. Поиск в глубину сначала проверяет каждую ветку полностью затем переходит к следующей. Поиск в глубину сначала проверяет все смежные вершины а затем опускается на уровень ниже`
  ],
  [
    `BigInt`,
    `Это строкове представление числа а потому математические операции проводить с ним нельзя. Единственное можно проводить не строгое сравнение с другими числами`
  ],
  [
    `Алгоритмы`,
    `Основные подходы:<br>
    1) полный перебор(brute force) - осуществляет полный проход по всем элементам структуры. Такой подход применим если у задачи нет другого решения<br>
    2) разделяй и властвуй - деление задачи на более мелкие. Например бинарный поиск в отсортированном массиве<br>
    3) динамическое программирование - похоже на пункт 2 но тут результат выполнения мелких задач кэшируется для дальнейшего использования<br>
    4) жадный алгоритм - алгоритм который ищет наиболее оптимальный путь на каждом локальном шаге не заботясь о последующих. К примеру выдача сдачи - сначала будет идти поиск купюры наибольшей величины затем из остатка будет также найдена наибольшая возможная купюра и т.д. пока не наберется вся сумма<hr>
    <b>Бинарный поиск</b><pre>
function binSearch(arr, target) {
let left = 0;
let right = arr.length - 1;
while(left < right) {
  const center = Math.floor((left + right) / 2);
  if (arr[center] === target) {
    return center;
  }
  if (arr[center] > target) {
    right = center - 1;
  }
  if (arr[center] < target) {
    left = center + 1;
  }
}
}</pre>Такой метод поиска работает только с отсортированными массивами. Сначала ищем центр массива и сравниваем с целевым элементом. Если они равны возвращаем индекс найденного элемента, если не равны то в зависимости от сравнения сдвигаем диапазон поиска. Если целевой меньше центрового элемента то сдвигаем правую рамку в центр без учета уже центрового элемента, если больше то сдвигаем левую рамку. Таким образом следующий поиск уже будет вестить в одной из части массива. Так продолжается пока не будет найден элемент или рамки диапазона не сомкнутся. Сложность O(log(n)). В случае если алгоритм использует 2 и более бинарных поиска сложность будет O(log(n) + log(m))`
  ],
  [
    `!Числа с плавающей точкой`,
    `<pre>
const a = .3 - .2;
const b = .2 - .1;
console.log(a === b);</pre>Результатом этого сравнения будет false т.к. такие числа имеют не точности и для подобного сравнения сначала нужно преобразовать их в целые числа`
  ],
  [
    `.toString(x?)`,
    `Метод преобразовывает субъект на которомы был вызван в строку. Необязательный параметр указывает на систему исчислений`
  ],
  [
    `.toFixed(x)`,
    `Преобразует число в строкус х кол-вом символов после .(заполняет 0)`
  ],
  [
    `.toExponential(x)`,
    `Преобразует число в строкус х кол-вом символов после . применяя экспоненциальную запись (5.425e + 6)`
  ],
  [
    `var`,
    `Переменные объявленные с помощью var будут автоматические записаны в глобальный объект а потому их можно будет использовать в любой части кода. Если обращение к пемеренной идет до ее объявления то ее значением будет undefined`
  ],
  [
    `Математические операнды`,
    `<b>x**2**3</b> - операнд возведения в степень. Приоритет такого операнда выше чем у +/- и читается такое выражение справа налево => x**8<hr>
    <b>1 + 1 + 'a'</b> - операнд сложения, читается слева направо => 2a<br>
    <b>--/++</b> - инкремент и декремент сначала пытаются преобразовать переменную в число и лишь потом произвести операцию`
  ],
  [
    `instanceOf`,
    `Позволяет узнать принадлежит ли объект слева к экземпляру класса справа<hr>
    <b>a instanceOf b</b> - сначала вычисляется прототип b (b.prototype), затем если найдено происходит его поиск в списке прототипов a. Если слева не объект вернет false, если справа не экземпляр класса вернет TypeError`
  ],
  [
    `in`,
    `<b>console.log(('x' in someObject));</b> - оператор позволяет узнать есть ли указанное свойство в объекте. Возвращает boolean<br>
    <b>'toString' in someObj => true</b> - потому что у любого объекта есть метод toString<br>
    <b>'0' in [1,2,3] => true</b> - т.к. массив тот же объект и у него есть свойств 0 где находится первый элемент`
  ],
  [
    `ООП в JS`,
    `<pre>
  const Person = function(age) {
    this.age = age;   <sup>1</sup>
  }
  Person.prototype.calc = function() {    <sup>2</sup>
    return 3000 - this.age;
  }
  const first = new Person(42);   <sup>3</sup>
  first.calc();</pre>
  1) функция конструктор позволяет создать прототип на основе которого в будущем можно будет создавать другие объекты. Может принимать аргументы для установки каких то свойств в объект который потом вернет функция<br>
  2) чтобы все экземпляры прототипа могли использовать какой то метод мы можем определить его в самом конструкторе или на его прототипе. В 1 случае при создании нового экземлпяра будет создаваться новая функция и в дальнейшем приведет к забиванию памяти. Во 2 варианте метод записывается в прототип и все экземпляры будут просто наследовать его не создавая новые функции<br>
  3) при использовании оператора new:<br>
  --создается пустой объект наследующий прототип объекта от которого он произошел<br>
  --вызывается конструктор и объекту привязывается this, а также устанавливаются свойства переданные конструктору<br>
  --конструктор неявно возвращает созданый ранее объект<hr>
  Каждый объект в JS имеет свойство __proto__ которое содержит ссылку на прототип от которого объект происходит. Самый верхний/начальный объект в цепочке прототипов содержит там null<pre>
  class Person {
    constructor(age) {    <sup>1</sup>
      this.age = age;
    }
    calc() {    <sup>2</sup>
      return 3000 - this.age;
    }
  }</pre>
  Классы в JS по сути это просто синтаксический сахар и на самом деле происходит то что описано в примере выше<br>
  1) конструктор делает тоже самое что и функция конструктор выше<br>
  2) любой метод созданный в классе будет автоматически добавлен в прототип самого класса<hr>
  Статические методы<pre>
  class Person {              const Person2 = function() {};
    static inc(x) {           Person2.inc = function(x) {
      return x++;               return x++;
    }                         }
  }</pre>2 варианта создания статического метода. Такие методы становятся собственным свойством объекта конструктора и не доступны в прототипе а значит не наследуются<pre>
  const A = function(a ,b) {
    this.a = a;
    this.b = b;
  }
  const B = function(a, b, c) {
    A.call(this, a, b);   <sup>1</sup>
    this.c = c;
  }
  B.prototype = Object.create(A.prototype);   <sup>2</sup></pre>
  Наследование с функциями конструкторами:<br>
  1) сначала с помощью привязки контекста вызываем конструктор на втором прототипе<br>
  2) затем с помощью Object.create наследуем прототип первого объекта<pre>
  class A {
    constructor(a, b) {
      this.a = a;
      this.b = b;
    }
  }
  class B extends A {   <sup>1</sup>
    constructor(a, b, c) {
      super(a, b);    <sup>2</sup>
      this.c = c;
    }
  }</pre>
  Наследование с использованием классов:<br>
  1) ключевое слово extends указывает наследование прототипа<br>
  2) в конструкторе перед использованием this обязательно сначала вызываем конструктор класса от которого идет наследование<pre>
  class A {
    #privat;
    static x;
    constructor (a) {
      this.a = a;
      #privat = 0;
    }
    #square(x) {
      return x*x;
    }
    static calc(x) {
      return this.a - this.#square(x);
    }
  }</pre>
  Приватные и статические поля/методы класса. Приватные еще толком не работают поэтому лучше использовать условное обозначение - _ в начале имени поля/метода`
  ],
  [
    `Операция присваивания (=)`,
    `<b>const a = b = c = 4;</b> - при присваивании интепритация идет справа налево`
  ],
  [
    `События загрузки страницы`,
    `<b>document.addEventListener('DOMContentLoaded')</b> - событие срабатывающее как только будет загружен и распарсен HTML код без сторонних ресурсов<br>
    <b>window.addEventListener('load')</b> - событие когда и разметка и сторонние ресурсы уже загружены<br>
    <b>window.addEventListener('beforeunload')</b> - событие срабатывает перед закрытием вкладки в виде алерта со стандартным текстом`
  ],
  [
    `IntersectionObserver`,
    `Позволяет делать какие то действия если наблюдаемые элементы входят в область видимости viewport или другого элемента<pre>
const observer = new IntersectionObserver((entries, observer) => {
  const [entry] = entries;    <sup>1</sup>
  if (!entry.isIntersecting) return;    <sup>2</sup>
  entry.target.classList.remove('hidden');    <sup>3</sup>
  observer.unObserve(entry.target);   <sup>4</sup>
}, {
  root: null,   <sup>5</sup>
  threshold: 0.15,    <sup>6</sup>
  rootMargin: '-20px'   <sup>7</sup>
});
document.querySelectorAll('section').forEach(section => observer.observe(section));   <sup>8</sup></pre>
Конструктор принимает 2 аргумента - callback функцию и объект с настройками<br>
1) получаем 1 элемент массива который содержит целевой элемент<br>
2) т.к. наблюдатель срабатывает дважды, когда элемент пересекает область и когда выходит из него, то проверяем на пересечение области<br>
3) чтобы взаимодействовать с самим элементом обращаемся к нему через свойство target<br>
4) также в самом обработчике мы можем потом взаимодействовать с самим объектом observer и в данном случае убираем наблюдение после одного срабатывания<br>
5) в объекте настроек это свойство по дефолту null что значит область наблюдения - viewport. Можно указать другой элемент<br>
6) порог пересечения на котором должен сработать обработчик где 0 - 0%, 1 - 100%<br>
7) можно указать отступ в пикселях от области наблюдения в которой должно произойти пересечение<br>
8) каждый элемент необходимо отдельно указывать для наблюдателя`
  ],
  [
    `Таймеры`,
    `<b>setTimeout(callback, x);</b> - позволяет запустить функцию единожды спустя х миллисекунд<br>
    <b>setInterval(callback, x);</b> - вызывает функцию каждые х секунд<pre>
  let i = 5;
  const timer = setInterval((text) => {
    if (i === 0) clearInterval(timer);
    i--;
    console.log(text);
  }, 1000, 'Hello');</pre>Чтобы остановить таймер сначала необходимо присвоить его переменной а потом передать в соотвествующую функцию<br>
  Также после указания времени таймера можно передать аргументы для callback функции`
  ],
  [
    `WeakMap`,
    `Аналог множества Map который позволяет сборщику мусора освобождать память более эффективно из-за того что ключами в таком множестве могут быть только объекты а не примитивы. В связи с этим он не имеет размер и не является итерируемым а потому не может использовать стандартные методы массива`
  ],
  [
    `Классы`,
    `Классы в JS по сути просто набор объектов<pre>
class Some {    <sup>1</sup>

}

const A = class {     <sup>2</sup>

}</pre>Классы объявляются 2 методами. Class declaration и class expression<pre>
class My {
static log() {
  console.log('hello');
}
}
My.log();</pre>
Статические св-ва и методы класса(static) вызываются не на экземпляре а на прямую на конструкторе. Статические методы и поля определяются вне конструктора<pre>
class My {
#value = 0;
}</pre>Приватные поля класса не могут быть прочитаны или изменены извне<hr>
При наследовании класса, в конструкторе сначала должен быть описан вызов super()до использования this. Если подкласс не имеет своего конструктора то он создается неявно и в нем вызывается метод super() родителя`
  ],
  [
    `arguments`,
    `<pre>
function someF() {
for (let i = 0; i < arguments.length; i++) {
  console.log(arguments[i]);
}
}</pre>В старых версиях JS использовалось свойство arguments которое ссылается на массив переданных в ф-цию аргументов`
  ],
  [
    `Дескрипторы`,
    `Позволяют более тонко настраивать отдельные св-ва объекта<pre>
const obj1 = {};
obj1.name = 'Bob';
Object.defineProperty(obj1, 'name1', { value: 'Bob', configurable: true, writable: true, enumerable: true });</pre>Обе записи создают идентичные св-ва. Чтобы использовать дескриптор используется метод defineProperty где в качестве 3 аргумента передается сам дескриптор с нужными параметрами св-ва<pre>
Object.defineProperties(obj1, {
name3: {
  value: 'Bob'
},
name4: {
  value: 'Bob',
  writable: false
}
});</pre>Также можно указать сразу несколько свойств с помощью defineProperties.В качестве 1 аргумента принимает сам объект а 2 аргумент объект содержащий имена добавляемых свойств которые содержат настройки. Если не указывать параметры св-ва то они будут установленны по умолчанию в true<hr>
Правила изменения объектов и свойств:<br>
1) если объект не расширяемый то можно только редактировать его св-ва<br>
2) если св-во не конфигурируемое то нельзя изменять его атрибуты configurable и enumerable а также изменять значение св-ва и его get/set. Также нельзя изменить св-во writable на true, только false<hr>
<b>Object.getOwnPropertyDescriptor(x, y)</b> - позволяет получить дескриптор свойста у в объекте х`
  ],
  [
    `Promise`,
    `Это объект который хранит состояние который используется для асинхронных действиий. Если асинхронное действие разрешится то состояние будет fullfiled(тогда вернет полученный результат), если же нет то rejected(тогда вернет причину ошибки).<pre>
const myProm = new Promise((res, rej) => {
setTimeout(() => {
  res('hello world');
}, 1000);
});

myProm.then((resp) => console.log(resp););</pre>Простой пример создания и использования Promise<hr>
Методы объекта Promise:<br>
<b>Promise.all(x)</b> - предназначен для выполнения сразу нескольких async ф-ций. В качестве аргумента принимает массив промисов и возвращает объект promise. Если хоть 1 промис будет отклонен то и конечный объект будет со статусом rejected. В противном случае вернет массив с полученными значениями каждого promise.<br>
<b>Promise.allSettled(x)</b> - аналог выше, но в любом случае возвращает массив объектов, где объект представляет каждый промис массива. Этот объект имеет 3 свойства:<br>
<b>-- .status</b> - статус выполнения промиса<br>
<b>-- .value</b> - какое то значение если промис был разрешен<br>
<b>-- .reason</b> - причина если промис был отклонен<br>
<b>Promise.race(x)</b> - тоже что и all но race дожидается лишь выполнения 1 промиса из массива после чего возвращает его результат<hr>
Чтобы использовать полученное значение или причину ошибки используется синтаксис await который может применятся только в async ф-циях`
  ],
  [
    `Функции генераторы`,
    `<pre>
function* gen(i) {
yield i + 1;
yield i + 2;
yield i + 3;
yield 'text';
}
const useGen = gen(5);
useGen().next(); // 6
useGen().next(); // 7
useGen().next(); // 8
useGen().next(); // 'text'</pre>Это такая ф-ция которая позволяет выйти и войти обратно при этом весь контекст сохраняется при каждом входе. При выполнении тело ф-ции выполняется не сразу. Ф-ция возвращает объект итератор с методом next(). При вызове этого метода выполняется тело генератора до оператора yield который в свою очередь либо вернет значение либо делигирует другой ф-ции генератору. Метод next() возвращает объект с полями value и done. При передаче методу next аргумента генератор прекращает свою работу и вместо значения которое должен передать yield вернет переданный аргумент<pre>
function* gen2() {
yield 2;
yield 3;
}

function* gen1() {
yield 1;
yield* gen2();
yeild 4;
}
const useGen = gen1();
useGen().next();  //1
useGen().next();  //2
useGen().next();  //3
useGen().next();  //4</pre>yield* позволяет делигировать выполнение другой ф-ции генератору<hr>
В случае если в генераторе значение возвращается с помощью return, то как только очередь дойдет до него все последующие вызовы прекратятся а метод next вернет объект с значением из return и done = true`
  ],
  [
    `Итерируемый объект`,
    `Это любой объект который имеет специальный итераторный метод который возвращает объект итератора. Сам итератор это объект с методом next() который возвращает результат итерации. Объект результата содержит свойста value и done. При итерации сначала вызывается итераторный метод. Затем на полученном итераторе многократно вызывается метод next пока значением свойста done результирующего объекта не будет true. Итерируемый метод имеет имя - <b>Symbol.iterator</b><pre>
class MyIterationObject {
constructor(from, to) {
  this.from = from;
  this.to = to;
}
[Symbol.iterator]() {
  let next = Math.ceil(this.from);
  let last = this.to;
  return {
    next() {
      return (next <= last) ? { value: next++ } : { done: true };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
}</pre>Реализация своего итерируемого объекта`
  ],
  [
    `URL`,
    `Объект для работы с URL. Имеет следующие свойства:<br>
    <b>.href</b> - полный адрес<br>
    <b>.origin</b> - полный домен<br>
    <b>.protocol</b> - http/https<br>
    <b>.host</b> - хост адреса с портом<br>
    <b>.hostname</b> - хост без порта<br>
    <b>.port</b> - порт<br>
    <b>.pathname</b> - путь между /.../ после хоста<br>
    <b>.search</b> - полный набор поисковых параметров (&q=)<br>
    <b>.hash</b> - все что после #<br>
    <b>.searchParams</b> - по сути является коллекцией(Set) поисковых параметров. Позволяет добавлять удалять и изменять элементы. При изменении автоматические обновляет поле search`
  ],
  [
    `Привязка контекста`,
    `Привязать контекст к функции можно 3 способами:<br>
    1) <b>someFunction.call(x, y, z);</b> - на функции вызывается метод call, где х - объект для привязки контекста (если не нужен то ставим null), y и z аргументы функции<br>
    2) <b>someFunction.apply(x, [y, z])</b> - тоже что и call только аргументы передаются в массиве<br>
    3) <b>someFunction.bind(x, y, z)</b> - похож на call, но метод bind в отличии от предыдущих двух просто возвращает новую функцию, а call и apply немеденно вызывают ее. С помощью bind также можно создать экземпляр функции с фиксированным значением аргументов:<pre>
function some(a, b, c) {
  return a + b + c;
}
const myBind = (fn, a) => function(...r) => fn(a, ...r);
const newSome = myBind(some, 11);
newSome(1, 5);</pre>
Также можно вызывать методы одного объекта с привязкой к другому - <br>
<b>obj1.someMethod.call(obj2);</b>`
  ],
  [
    `Контекст`,
    `По сути контекст это внешняя область видимости. У каждой ф-ции свой контекст. Объект this является ссылкой на внешнюю область видимости или контекст. Контекст может менятся взависимости от того как была объявлена ф-ция или как она вызвана:<br>
    1) у стрелочных ф-ций контекстом будет являться область видимости в которой они были определены<br>
    2) если ф-ция объявленная декларативно то ее объект this будет ссылаться на глобальную область видимости (window) в нестрогом режиме или undefined в строгом<br>
    3) если ф-ция была вызвана как метод какого то объекта то объект this будет ссылаться на этот объект<pre>
const o = {
someFunc() {
  return this;
}
};
const a = o.someFunc;
a();</pre>
    4) если метод объекта был присвоен отдельной переменной, то при ее вызове контекст будет потерян<br>
    5) для простых декларативных ф-ций мы можем указать явно или привязать контекст с помощью методов apply, call и bind<br>
    6) в обработчиках событий контекстом функции будет является объект на котором произошло событие, даже если передать метод объекта. Но это можно исправить - <b>btn.addEventListener('click', obj.method.bind(obj));</b>`
  ],
  [
    `Преобразование типов`,
    `<pre>
<b>Значение     toString        parseInt/Number bool</b>
undefined       'undefined'     NaN             false
null            'null'          0               false
true            'true'          1               true
false           'false'         0               false
''              ''              NaN             false
'1.2'           '1.2'           1.2             true
'one'           'one'           NaN             true
0               '0'             0               false
-0              '-0'            0               false
1               '1'             1               true
Infinity        'Infinity'      Infinity        true
-Infinity       '-Infinity'     -Infinity       true
NaN             'NaN'           NaN             false
{}              'ObjectObject'  NaN             true
[]              ''              NaN/0           true
[9]             '9'             9               true
['a']           'a'             NaN             true</pre>
<b>Boolean(), Number(), String()</b> явное преобразование<hr>
<b>3 + '' => string</b><br>
<b>+'4' => number</b> неявное преобразование<br>
<b>'4' - 0 => number</b><br>
<b>!!'' => false</b><br>
<b>n..toString()</b> - для преобразования числа в строку ставят 2 точки потому что интерпритатор ожидает сначала увидеть число в виде n.m а потом уже видит метод<br>
При преобразовании объекта сначала:<br>
1) приоритет у преобразования в строку<br>
2) приоритет у преобразования в число<br>
3) собственное преобразование<br>
При операциях с объектом сначала ищется метод valueOf, если он не найден тогда вызывается toString
Также все объекты всегда == true<hr>
Порядок преобразования при сравнении с < > => =<<br>
1) если есть объект то сначала интепритатор пытается получить его valueOf а потом toString<br>
2) если оба значения строки то они сравниваются в порядке определенным числовым порядком 16 битных значений Unicode (при сравнении строк заглавные буквы всегда > обычных)<br>
3) если хоть 1 значение не строка и не объект то оба преобразуются в число<br>
4) если хоть 1 значение NaN то всегда возвращается false`
  ],
  [
    `Встроенные методы строки`,
    `Строки в JS являются иммутабельными поэтому все методы возвращают новые строки<hr>
    <b>.substring(x, y)</b> - возвращает обрезанную строку с x + 1 до y индекса включительно<br>
    <b>.slice(x, y)</b> - тоже что и выше<br>
    <b>.indexOf(x, y?)</b> - возвращает индекс первого найденного символа х. y необязательный 2 параметр который указывает с какого индекса начинать поиск. Если позиция не найдена вернет -1<br>
    <b>.lastIndexOf(x)</b> - возвращает индекс последнего вхождения символа<br>
    <b>.startWith(x)</b> - проверяет начинается ли строка с переданного в нее аргумента и возвращает boolean<br>
    <b>.endWith(x)</b> - тоже что и выше только проверяет конец строки<br>
    <b>.includes(x)</b> - проверяет наличие в строке переданного аргумента<br>
    <b>.normalize()</b> - нормализация Unicode<br>
    <b>.charAt(x)</b> - выводит символ в строке под индексом x<br>
    <b>.charCodeAt(x)</b> - вернет 16 битное число символа в строке под индексом x<br>
    <b>.padStart(x, y?)</b> - заполняет строку символами у(если не передан то пробелами) в начале пока длина строки не станет равна х<br>
    <b>.padEnd(x, y?)</b> - тоже что и выше только заполняет с конца<br>
    <b>.trim()</b><br>
    <b>.trimEnd()</b> - удаляет пробелы в строке - везде/в конце/ в начале<br>
    <b>.trimStart()</b><br>
    <b>.localeCompare(x)</b> - сравнивает как целевая строка должна быть отсортированна относительно переданной. Возвращает 1 если строка распологается до х и -1 если после<br>
    <b>.repeat(x)</b> - возвращает исходную строку повторенную х раз<br>
    <b>.search(x)</b> - выдает позицию первого совпадения в строке переданного значения х (строка или регулярное выражение + не работает с флагом g)<br>
    <b>.match(x)</b> - вернет массив всех совпадений в строке. 1 элемент массива будет полученное совпадение, последующие элементы будут совпадениями найденные по группам если такие были - (). При неглобальном поиске также имеет ряд свойств:<br>
    <b> .input</b> - входная строка<br>
    <b> .index</b> - индекс позиции совпадения<br>
    <b> .groups</b> - если использовались именнованные группы они будут содержаться в этом объекте в виде - [имя_группы]: найденное_совпадение<br>
    <b>.matchAll()</b> - тоже что выше только с флагом g<hr>
    Регулярные выражения также содержат несколько свойств:<br>
    <b>.source</b> - строка с исходным выражением(readonly)<br>
    <b>.flags</b> - строка с флагами<br>
    <b>.global</b> - возвращает boolean задан ли флаг g<br>
    <b>.multiline</b> - boolean задан ли флаг m<br>
    <b>.ignoreCase</b> - boolean задан ли флаг i<br>
    <b>.dotAll</b> - boolean задан ли флаг s<br>
    <b>.unicode</b> - boolean задан ли флаг u<br>
    <b>.sticky</b> - boolean задан ли флаг y<br>
    <b>.test(x)</b> - boolean проверяет содержит ли строка х выражение`
  ],
  [
    `Встроенные математические методы`,
    `<b>.pow(a, b)</b> - возводит числоа а в степень b<br>
    <b>.round(a)</b> - округление до ближайшего целого<br>
    <b>.ceil(a)</b> - округление в большую сторону до целого<br>
    <b>.floor(a)</b> - округление в меньшую сторону до целого<br>
    <b>.abs(a)</b> - модуль числа a<br>
    <b>.sqrt(a)</b> - квадратный корень числа a (a в степени 0.5)<br>
    <b>.random()</b> - возвращает рандомное число от 0 до 0.9999... Чтобы получить конкретное целое число в диапазоне от 0 до n нужно сначала умножить результат ф-ции на n + 1 а затем округлить до меньшего - <b>const random = Math.floor(Math.random() * 6);</b> - рандомное число от 0 до 5<br>
    <b>.trunc(a)</b> - преобразует в целое число отбрасывая дробную часть (4.5 => 4)`
  ],
  [
    `Предикаты`,
    `Это ф-ция которая всегда возвращает boolean. Такие ф-ции принято именовать начиная с is..., has..., can...`
  ],
  [
    `Тернарный оператор`,
    `<b>console.log(value === true ? 'Yes' : 'No');</b> - логический оператор наподобии if else. Называется так потому что имеет 3 операнда`
  ],
  [
    `window.location`,
    `Объект возвращающий текущую ссылку. Имеет следующие свойства:<br>
    <b>.href</b> - полная текущая ссылка<br>
    <b>.protocol</b> - протокол адреса (http/https)<br>
    <b>.host</b> - домен сайта<br>
    <b>.port</b> - порт<br>
    <b>.pathname</b> - путь к ресурсу (.../path/)<br>
    <b>.search</b> - параметры после ?key=value<br>
    <b>.hash</b> - все что после #`
  ],
  [
    `Наследование классов`,
    `<pre>
class Some {
constructor(a, b) {
  this.a = a;
  this.b = b;
}
}
class Another extends Some {
constructor(a, b, c) {
  super(a, b);
  this.c = c;
}
}</pre>При наследовании другого класса в конструкторе сначала вызывают конструктор родителя с помощью super()`
  ],
  [
    `.filter()`,
    `Метод массива возвращающий новый массив после отфильтровывания на основе заданных условий в полученной callback ф-ции в виде аргумента.<hr>ar.filter(it => it); - вернет новый массив но уже без пустых ячеек т.к. вовзращает только те что подходят под условие, в данном случае true`
  ],
  [
    `Что такое DOM`,
    `Объектная модель документа представляющая интерфейс позволяющий взаимодействовать с разметкой страницы`
  ],
  [
    `.hasOwnProperty(х)`,
    `Метод объекта позволяющий искать свойство с именем х среди ТОЛЬКО собственных свойств объекта`
  ],
  [
    `.propertyIsEnumerable(x)`,
    `Метод объекта позволяющий искать свойство с именем х среди ТОЛЬКО собственных свойств объекта а также проверяет участвует ли оно в переборах`
  ],
  [
    `Object.getOwnPropertyNames(x)`,
    `Метод возвращающий массив из имен свойст объекта х которые являются Symbol`
  ],
  [
    `Object.getOwnPropertySymbols(x)`,
    `Метод возвращающий массив из имен свойст объекта х. В перечислении участвуют также свойства без enumerable`
  ],
  [
    `Object.assign(x, y)`,
    `Возвращает модифицированный объект х с добавленными к нему св-ми из объекта у. Если в целевом объекте уже существует св-во то оно будет перезаписано из крайнего левого объекта. Если целевой объект имеет методы то будет скопировано вычисление этого метода. Также не копирует свойства конфигурации(дескрипторы)`
  ],
  [
    `.valueOf()`,
    `Метод объекта который позволяет получить примитивное значение объекта отличное от строки<br>
    <b>obj.prototype.valueOf = function() { return 4; };</b> - переопределение метода`
  ],
  [
    `Примитивы в JS`,
    `Примитивами являются простые переменные типа number, string, boolean. Примитивы являются иммутабельными поэтому следующий код не изменяет строку<pre>
let string = 'Some text';
string[0] = 'X';
console.log(string);  // Some text</pre>Чтобы изменять значение примитивов необходимо это делать через присваивание нового значения`
  ],
  [
    `Регулярные выражения`,
    `<pre>
const r1 = /a/;
const r2 = new RegExp('abc', 'g');</pre>Создаются 2 способами. 1 с помощью литерала //, 2 с помощью конструктора где 1 аргумент выражение а 2 флаг<hr>
Управляющие символы:<br>
1) \\0 - null<br>
2) \\t - табуляция<br>
3) \\v - вертикальная табуляция<br>
4) \\f - перевод страницы<hr>
<b>[a,b,c]</b> - класс символов ищет 1 символ из указанных<br>
<b>[^a,b,c]</b> - тоже самое но с исключением, ищет символ не равный указанным<br>
<b>[a-zA-z0-9]</b> - указание диапазона<br>
<b>\\s</b> - пробельный символ<br>
<b>\\S</b> - не пробельный символ<br>
<b>\\w</b> - любой символ a-z && 0-9<br>
<b>\\W</b> - символ не входящий в a-z 0-9<br>
<b>\\d</b> - любое число<br>
<b>\\D</b> - любое не число<br>
<b>.</b> - любой символ за исключением переноса строки или другого разделителя строк<hr>
Символы повторений (указываются после шаблона):<br>
<b>{x, y}</b> - диапазон повторений от х до у<br>
<b>{x, }</b> - диапазон от х до неизвестно<br>
<b>{x}</b> - ровно х повторений<br>
<b>?</b> - 0 или 1 повторение<br>
<b>+</b> - 1 и более повторений<br>
<b>*</b> - 0 и более повторений<hr>
При поиске совпадений находится самая длинная цепочка из возмжных<hr>
<b>/('ab'|'ba')/</b> - группировка выражений и использование логического ИЛИ<br>
<b>/(['"])[^'"]\\1/</b> - при использовании группировки выражений их потом можно вставлять по индексу(\\n), все сгруппированные выражения получают индекс в порядке их описания в выражении слева направо. Такие ссылки нельзя вставлять в классы([])<br>
<b>(?:...)</b> - благодаря указателю данная группа не будет участвовать в индексировании и не получи ссылку<br>
<b>/(?&lt;name&gt;...)[1-4]\\k&lt;name&gt;/</b> - вместо индекса таким образом можно задать имя и использовать в дальнейшем с помощью \\k<br>
<b>\\b</b> - якорь указывающий на границы слова (напр. /\\bSome\\b/)<br>
<b>\\B</b> - якорь указывающий что шаблон не на границе слова<br>
<b>^</b> - якорь начала строки<br>
<b>$</b> - якорь конца строки<hr>
Якори просмотра позволяют добавлять к шаблону условия выборки. Они не попадают в искомый шаблон:<br>
<b>?=</b> - якорь просмотра вперед позволяет указать условие после шаблона - /[jJ]ava(?=\\:)/ - поиск слово j(J)ava после которого идет :<br>
<b>?<=</b> - аналог выше только условие до шаблона<br>
<b>?!</b> - якорь исключения - /[jJ]ava(?![sS]cript)/ - искать слово j(J)ava после которого нет слова s(S)cript<br>
<b>?<!</b> - аналог выше только для условия до шаблона<hr>
Флаги:
<b>g</b> - флаг глобального поиска<br>
<b>i</b> - флаг регистра<br>
<b>m</b> - флаг многострочного поиска<br>
<b>u</b> - флаг работы с Unicode<br>
<b>y</b> - флаг поиска на заданной позиции`
  ],
  [
    `Массив`,
    `По сути это итерируемый объект. При обращении к элементу массива индекс сначала приводится к строке а потом получаем значение как из обычного объекта<pre>
const a = [,];
const b = Array.from(5);
const c = [];
c[100] = 0;</pre>Создание разреженных массивов. Это массив в котором индексы элементов не образуют последовательную цепочку чисел начиная с 0. По сути просто массив с заданной длиной но некоторые элементы массива остаются без индекса. Такой массив занимает больше памяти и медленнее происходит поиск элементов<br>
При переборе такого массива лучше использовать forEach т.к. он не обращается к элементам undefined<br>
При использовании map() в таком массиве мы получим массив такой же длины что и исходный с элементами undefined, но в преобразовании в map они участвовать не будут<hr>
Если массиву задать длину меньше чем уже есть то элементы после индекса length - 1 пропадут. Если задать длину больше чем уже имеется то массив станет разреженным<hr>
Методы массива:<br>
1) <b>.find((x) => x === y)</b> - поиск элемента в массиве удовлетворяющему условие в cb ф-ции. Если элемент найден цикл остановится и вернет элемент, или же вернет undefined<br>
2) <b>.findIndex(calllback)</b> - тоже что и метод выше но возвращает индекс найденного элемента<br>
3) <b>.reduceRighth(callback)</b> - тоже что и reduce но начинает цикл справа налево<br>
4) <b>.flat(x?)</b> - возвращает новый массив убирая при этом уровни вложенности. Если аргумент не передан то убирает только начальный уровень. Х - необязательный аргумент указывающий сколько уровней вложенности необходимо убрать ([1, [2, 3]].flat() => [1])<br>
5) <b>.flatMap(callback)</b> - сначала сработает как map с cb ф-цией а потом применится flat<br>
6) <b>.splice(x, y, ...z);</b> - метод для вставки или удаления части массива. Х начальный индекс, у количество элементов для удаления, z необязательные элементы. Если z не указан то просто удаляет часть массива, если указан делает вставку. Данный метод изменяет целевой массив<br>
---<b>.toSpliced(x, y, ...z)</b> - аналогичный метод не изменяет исходный массив а возвращает новый<br>
7) <b>.copyWithin(x, y, z)</b> - делает срез массива и вставляет его в исходный при этом видоизменяя исходный массив. Изменения происходят путем наложения нового массива на старый. х - индекс с которого начать наслоение, у - индекс с которого начать срез, z - конечный индекс среза<br>
---<b>.with(x, y)</b> - тоже что и выше но не изменяет исходный массив а вернет новый, где х - индекс заменяемого элемента а у сам новый элемент<br>
8) <b>.join(x?)</b> - объединяет все элементы массива в строку по умолчанию через ,. Если передан аргумент то разделителем между элементами становится он<br>
9) <b>.subArray(x, y)</b> - возвращает часть массива где х начальный индекс а y конечный. В отличии от slice он не создает новый массив а просто возвращает часть существующего<hr>
Вызов метода toString() на массиве является аналогом вызова join() без аргументов и не учитывает вложенность<pre>
const o = {};
o[0] = 0;
o[1] = 1;
o.length = 2;</pre>Создание массивоподобного объекта. Теперь такой объект можно перебрать циклом for<br>
10) <b>.slice(x, y)</b> - возвращает часть массива на основе целевого где х начальный индекс а у конечный(не включается в результат)<br>
11) <b>.reverse()</b> - изменяет текущий массив меня порядок элементов на противоположный<br>
---<b>.toReversed()</b> - делает тоже самое но не изменяет исходный массив а возвращает новый<br>
12) <b>.findLast(x => x > 0)</b> - позволяет найти последний элемент массива который удовлетворяет условиям в callback или undefined<br>
13) <b>.findLastIndex(x => x > 0)</b> - вернет индекс последнего элемента массива который подходит под условия или -1<br>
14) <b>.at(x)</b> - позволяет получить элемент по заданному индексу х, который также может быть отрицательным числом. Удобен для доступа к последнему элементу<br>
15) <b>.sort((a, b) => a - b)</b> - Метод массива возвращает отсортированный массив по алфавиту (при этом изменяет исходный массив), где числовые значения также переводятся в строку. Для сортировки по числу можно в метод передать callback где будет описано как x относится к y. Если результат сравнения положительный то х будет в начале и наоборот - <pre>
array.sort((x, y) => {
  return x - y;
});</pre>
!!! Если нужно отсортировать массив с объектами по свойству которое содержит boolean или строку можно сделать следующее:<br>
1) boolean - преобразовать значение в число и вернуть разницу между двумя элементами в callback<br>
2) строка - вызвать на первом элементе метод localeCompare() и передать 2 элемент что также вернет число от -1 до 1<br>
---<b>.toSorted((a, b) => a - b)</b> - принцип такой же как у .sort() но при этом не изменяет исходный массив а возвращает новый<br>
<b>Array.prototype.join.call(o, '+');</b> Массиво подобные объекты не наследуют прототип Array и потому не могут использовать методы массивов. Для вызова метода для такого объекта используется call где мы передаем сначала сам объект а затем аргументы для ф-ции которую хотим вызвать`
  ],
  [
    `Объект`,
    `Это неупорядоченная коллекция свойств, каждое из которых имеет имя и значение. Свойста имеют 3 атрибута:<br>
    1) writable - можно ли менять значение св-ва<br>
    2) enumerable - участвует ли св-во в переборах for in<br>
    3) configurable - можно ли удалять св-во или изменять его атрибуты<br>
    Все собственные св-ва имеют эти атрибуты в значении true<hr>
    Если мы попытаемся получить какое то свойство у объекта то интепритатор сначала ищет его в самом объекте. Если не находит поиск продолжается в его ближайшем наследуемом прототипе и так продолжается либо пока св-во не будет найдено, либо вернет undefined. При попытке получить свойство у не существующего свойста получим TypeError т.к. null и undefined не имеют никаких свойств<hr>
    Порядок перечисления свойств объекта:<br>
    1) сначала идут свойста чье имя является целым положительным числом, по числовому порядку<br>
    2) затем идут свойста с именем строчным в порядке в котором они были добавлены<br>
    3) далее идут свойста с именем Symbol<br>
    4) дальше все повторяется для каждого прототипа. Если свойство уже было перечислено то оно пропускается<pre>
const obj = {
x: 5,
get getter() {
  return this.x;
},
set setter(v) {
  this.x = v;
}
};

obj.setter = 1;
console.log(obj.getter);</pre>Синтаксис get и set. Они связывают свойство объекта с определенной ф-цией и в последующем при обращении к этому св-ву она будет вызвана. При обращении к get вызывается ф-ция которая возвращает значение. При обращении к set вызываетс ф-ция устанавливающая новое значение переданное в аргумент в виде обычного присваивания значения<hr>
Некоторые методы объектов:<br>
<b>Object.isExtensible(x)</b> - проверяет является ли объект х расширяемым<br>
<b>Object.preventExtensions(x)</b> - делает получаемый объект х нерасширяемым. После этого объект уже невозможно вернуть в исходное состояние<br>
<b>Object.isSealed(x)</b> - проверяет является ли объект запечатанным<br>
<b>Object.seal(x)</b> - запечатывает объект. Делает его не расширяемым и не конфигурируемым. Свойства такого объекта нельзя удалить или изменить, можно только изменить значение св-ва<br>
<b>Object.isFrozen(x)</b> - проверяет заморожен ли объект<br>
<b>Object.fromEntries(x)</b> - принимает коллекцию (Map) [[key, value]] и превращает в объект где key - становится свойством а value - значением<br>
<b>Object.freeze(x)</b> - замораживает объект. Тоже что и seal + вдобавок объект становится readonly<hr>
Некоторые св-ва объектов:<br>
<b>[Symbol.hasInstance]()</b> - этот метод является альтернативой проверки instanceof<br>
<b>[Symbol.toStringTag]()</b> - метод возвращает строковый литерал, который будет добавлен к описанию объекта при вызове на нем toString() (напр. - [Object myName])<br>
<b>[Symbol.toPrimitive](x)</b> - метод который пытается преобразовать в примитивное значение где х является переданным типом и возвращает элементарное значение объекта`
  ],
  [
    `Примеры простого зацикливания`,
    `<b>for (;;) {}</b><br>
    <b>while(true){}</b><br>
    <b>for (let k in array) {array.push(k + 1);}</b>`
  ],
  [
    `Асинхронность в JS`,
    `<img src="./img/async.jpg" style="width: 500px"><br>
    При считывании кода движок JS помещает весь синхронный код в callstack, где тот выполняется в порядке очереди. Весь асинхронный код помещается в блок web api где тот выполняется фоном. Как только какой то асинхронный код выполнится, callback который затем должен быть вызван отправляется в одну из специальных очередей, где он будет ждать пока eventloop доберется до него. Сам eventloop каждый тик сначала проверяет callstack и если он пуст то берет первый из очереди callback и помещает его в callstack для его дальнейшего выполнения.<br>
    Есть 2 очереди для callback из асинхронного кода которые по сути одинаковы просто у microtask queue приоритет выше чем у обычной очереди callback. Поэтому на каждом тике eventloop сначала проверяет очередь microtask и если тот пуст только потом смотрим callback queue. В microtask очереди содержаться callback основанные на промисах`
  ],
  [
    `XMLHTTPRequest`,
    `Устаревший способ создания запросов к серверу<pre>
const request = new XMLHTTPRequest();
request.open(x, y);   <sup>1</sup>
request.send();     <sup>2</sup>
request.addEventListener('load', function() {
  const data = this.responseText;   <sup>3</sup>
  ....
});</pre>
1) настройка запроса где х - метод ('GET'), y - URL<br>
2) отправка запроса<br>
3) чтобы работать с полученным ответом необходимо сначала подписаться на событие load, которое сработает как только ответ будет получен. Тело ответа хранится в свойстве объекта request - responseText в виде строки`
  ],
  [
    `JSON.parse(x) / JSON.stringify(x)`,
    `1) метод преобразует строку в объект<br>
    2) преобразует объект в строку<br>
    !!! При подобном превращении теряется прототип объекта !!!`
  ],
  [
    `Number.isFinite(x)`,
    `Метод объекта проверяет является ли х конечным числом, т.е. не NaN и не +-infinity. Если вызывать метод на объекте Number то также проверяет тип х, если вызвать отдельно как функцию то сначала пытается неявно привести к числу`
  ],
  [
    `navigator.language`,
    `Свойство объекта позволяет получить локализацию браузера (напр. en-US)`
  ],
  [
    `navigator.geolocation`,
    `Свойство объекта позволяет позволяет взаимодействовать с объектом геолокации<hr>
    <b>navigator.geolocation.getCurrentPosition(cb1, cb2);</b> - получить текущую геолокацию где <br>
    cb1 - колбэк в случае успеха, который принимает объект с данными геолокации<br>
    cb2 - колбэк в случае неудачи`
  ],
  [
    `Intl`,
    `Объект интернационализации. Содержит методы для форматирования чисел, дат и строк в соответствии с локализацией<pre>
const date = new Intl.DateTimeFormat('en-US', {   <sup>1</sup>
  month: 'long',    <sup>2</sup>
  day: 'numeric',
  year: '2-digit'
}).format(new Date());    <sup>3</sup></pre>
1) 1 аргументом получает описание локализации<br>
2) 2 аргумент объект настроек где можно указать:<br>
long - описание в виде слова<br>
numeric - числовое описание<br>
2-digit - в виде двузначного числа<pre>
const num = new Intl.NumberFormat('en-Us', {
  style: x,   <sup>1</sup>
  unit: y,    <sup>2</sup>
  currency: z, <sup>3</sup>
  useGrouping: t  <sup>4</sup>
}).format(5);</pre>
Объект настроек имеент следующие поля:<br>
1) указывает сущность строки и имеет следующие значения:<br>
percent - проценты<br>
unit - единицы измерения<br>
currency - валюты<br>
2) настройка если стиль единицы измерения (напр. 'celsius')<br>
3) настройка валют если стиль валюты (напр. 'USD')<br>
4) указывает использовать ли разделители чисел (default = true)`
  ],
  [
    `Numeric separator`,
    `<b>const a = 1_500_000;  // 1500000</b> - Числовой разделитель позволяет записывать числа в более понятном для глаза виде, но при этом оно до сих пор остается обычным числом`
  ],
  [
    `Свойства и методы node элементов`,
    `<b>.parentNode</b> - свойство содержит родительский элемент<br>
    <b>.children</b> - дочерние элементы<br>
    <b>.childElementCount</b> - кол-во дочерних элементов<br>
    <b>.firstElementChild</b> - первый дочерний элемент или null<br>
    <b>.lastElementChild</b> - последний дочерний элемент<br>
    <b>.childNodes</b> - все дочерние узлы<br>
    <b>.nextSibling</b> - следующий узел<br>
    <b>.previousSibling</b> - предыдущий узел<br>
    <b>.nodeType</b> - численный указатель типа узла (document, element, text, comment)<br>
    <b>.nodeValue</b> - текстовое содержание узла (text || comment)<br>
    <b>.nodeName</b> - имя HTML дескриптора<br>
    <b>.removeAttribute(x)</b> - удалить атрибут х<br>
    <b>.insertAdjacentHTML(x, y)</b> - вставить разметку у в элемент где х указание куда именно происходит вставка - <br>
    <b><sup>1</sup>&lt;div&gt;<sup>2</sup>some text<sup>3</sup>&lt;/div&gt;<sup>4</sup></b><br>
    1) beforebegin<br>
    2) afterbegin<br>
    3) beforeend<br>
    4) afterend<br>
    В случае если необходимо добавить элемент в виде строки HTML разметки лучше использовать этот метод чем менять innerHTML. Дело в том что при использовании последнего каждый раз когда происходит обновление/перезапись, то все элементы находящиеся уже в разметке теряют связь с ссылкой на него в JS<pre>
    const div = document.querySelector('div');
    div.innerHTML = '&lt;span&gt;some text&lt;/span&gt';
    const span = div.querySelector('span');
    div.innerHTML += '&lt;span&gtnew text&lt;/span&gt';
    span.textContent = 'edited first text';</pre>
    В данном случае изменить содержимое 1 спана будет невозможно т.к. при добавлении новой строки в innerHMTL связь элемента будет потеряна`
  ],
  [
    `async/await`,
    `Это синтаксический сахар который позволяет писать асинхронный код в виде синхронного. Сами async функции всегда возвращают промис независимо от того что переданно в return. Поэтому в случае если в функции возможна ошибка ее следует отловить с помощью try/catch и вернуть новый экземпляр ошибки<hr>
    В модулях await можно использовать без ключевого слова async, но такой подход будет блокировать главный поток как в коде самого модуля так и в коде главного модуля куда он импортируется`
  ],
  [
    `Чистая функция`,
    `Это функция которая каждый раз будет возвращать одно и тоже значение если значение аргумента не изменялось. Другими словами это функция которая не зависит от внешних данных`
  ],
  [
    `declarative/imperative programming`,
    `Это 2 подхода программирования<pre>
const double = (arr) => {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(arr[i] * 2);
  }
  return result;
}</pre>
Императивный подход - когда мы объясняем программе по шагам что и как нужно делать<pre>
const double = arr => arr.map(item => item * 2);</pre>
Декларативный подход - когда мы объясняем что нужно сделать`
  ],
  [
    `module pattern`,
    `<pre>
const MyModule = (function() {
  const somePrivate = 'text';
  const method = function() {
    return 'some text with ' + somePrivate;
  }
  return { meth };
})();
MyModule.meth();</pre>
Паттерн иммитирует модуль. Такой подход был полезен до того как были придуманы модули в ES6. Благодаря замыканию мы изолировали часть логики и возвращали только публичные методы и поля`
  ],
  [
    `Собственные события`,
    `<pre>
async function some() {
document.dispatchEvent(new CustomEvent('busy', { detail: true }));    <sup>1</sup>
...some code...
document.dispatchEvent(new CustomEvent('busy', { detail: false }));
}

document.addEventListener('busy', (e) => {
e.detail ? showSpinner() : hideSpinner();
});

some();</pre>Создание собственного события. Сначала в пункте 1 мы инициализируем срабатывание события куда передаем конструктор нового события. Этот конструктор принимает 1 арг. название события и 2 арг. дополнительные параметры для объекта события. После мы вешаем обработчик события на элемент или документ и производим какие то действия`
  ],
  [
    `Процесс загрузки страницы`,
    `1) браузер создает Document и начинает анализ. Добавляет элементы и текстовые узлы по мере анализа. В этот момент свойство .readyState = loading<br>
    2) когда анализатор встречает &lt;script&gt; без атрибутов и модулей начинается выполнение скрипта и анализ страницы приостанавливается<br>
    3) если встречается async script то начинается его выполнение с попутно продолжающимся анализом страницы<br>
    4) после полного анализа страницы св-во .readyState = interactive. В этот момент начинается выполнение отложенных скриптов(defer)<br>
    5) далее идет инициализация DOMContentLoaded. В этот момент все еще может идти выполнение async скриптов<br>
    6) когда все сценарии выполнены и загруженны все сторонние ресурсы св-во .readyState = complete и инициализируется событие load`
  ],
  [
    `Proxy`,
    `<pre>
const obj = { x: 4 };
const proxy = new Proxy(obj, {
get(obj, prop) {
  return 'text';
}
});
obj.x;    // 4
proxy.x;  // 'text'</pre>Объект Proxy служит оболочкой для других объектов и позволяет перехватывать различные действия над целевым объектом. В качестве 1 аргумента принимает целевой объект а 2 аргумент это объект с настройками. Если объект пуст то все действия напрямую будут передоваться в целевой объект. При перехвате запроса на получение св-ва используется метод get который принимает 1 арг. - сам объект, 2 арг. - имя св-ва. При перехвате действия изменения св-ва объекта используется метод set. 1 арг. - целевой объект, 2 арг. - имя св-ва, 3 арг. - новое значение. В любом случае этот метод должен вернуть boolean. true если запись прошла успешно и false если нет`
  ],
  [
    `for in`,
    `<pre>
for (let k in obj) {
console.log(obj[k]);
}</pre>Цикл позволяет перебрать все собственные и унаследованные свойства неитерируемого объекта. Сначала идет вычисление самого объекта, затем идет вычисление переменной k, т.е. по сути создается переменная k и в нее подставляется имя свойста объекта. После всего происходит выполнение кода в теле цикла. Сам цикл видит только перечисляемые свойства, т.е. не видит методы и встроенные свойства<pre>
const obj = {
x: 1, y: 2, z: 3
};
let a = [], i = 0;
for (a[i++] in obj) {}</pre>Благодаря вычислению переменной k из примера выше мы можем таким образом заполнить массив ключами объекта`
  ],
  [
    `switch`,
    `<pre>
const a = 4;
switch(a) {
case 3:
  console.log(3);
  break;
case 4:
  return 'its 4';
default:
  console.log('not found');
  break;
}</pre>Цикл сравнения значений переменнной. Сначала выполняется вычисление аргумента (а). Затем идет последовательное строгое сравнение со значениями в case. Сам код в case выполняется позже. Если case что то возвращает то break ставить необязательно`
  ],
  [
    `;`,
    `<b>for (const i = 0; i < arr.length; i ++ );</b> - пустой оператор. Используется редко, одно из применений при создании цикла с пустым телом`
  ],
  [
    `.keyCode`,
    `Свойство объекта event(события) позволяющая получить номер нажатой клавиши`
  ],
  [
    `delete`,
    `<b>delete obj.someKey;</b>Метод позволяет удалить свойство из объекта или массива<br>
    1) при удалении свойста из массива просто заменяет его значение на undefined<br>
    2) при успешном удалении вернет true<br>
    3) при попытке удалить несуществующее св-во вернет true<br>
    4) при удалении переменной вернет false или SyntaxError в строгом режиме<br>
    5) при удалении неудаляемого св-ва вернет false или TypeError`
  ],
  [
    `REST API`,
    `Это способ взаимодействия сайта или приложения с сервером. Основные принципы REST API:<br>
    1)Отделение клиентской части от серверной<br>
    2)Сервер должен получать только ту информацию которая необходима для отправки ответа<br>
    3)В данных запроса должно быть указано нужно ли кэшировать данные<br>
    4)Единство интерфейса. Все данные должны запрашиваться по одному URL<br>
    5)Многоуровневость. Т.е. в серверной части компоненты отделены друг от друга и ничего не знают о соседях<br>
    6)Позволяется отправка кода по запросу<br>
    Методы REST API:<br>
    1)GET получение каких то данных<br>
    2)POST отправка данных на сервер<br>
    3)DELETE удаление данных<br>
    4)PUT обновление данных`
  ],
  [
    `Типы данных`,
    `1. string<br>2. number<br>3. boolean<br>4. symbol<br>5. object<br>6. null<br>7. undefined<br>8. bigInt`
  ],
  [
    `Symbol`,
    `Символьный литерал. Принимает строковый и возвращает новый символьный. Если вызвать два раза с одним значением вернет два разных символа. Такой литерал нужен чтобы избежать перезаписи свойств объекта например<hr>
    <b>.for(x)</b> - возвращает уже созданный символ или создает новый если такого нет<br>
    <b>.keyFor(x)</b> - возвращает строковое значение символа`
  ],
  [
    `Типы функций`,
    `1. declaration - function n() {} - создается до выполнения кода и такую ф-цию можно вызвать в любой части кода<br>2. expression - const a = function() {} - вызов такой ф-ции возможен после ее объявления`
  ],
  [
    `.parseInt()`,
    `Метод преобразует строку в число. Если строка начинается с числового значения то преобразование будет идти пока интерпритатор не встретит первое не числовое значение. Если же строка начинается с не числового то вернет NaN`
  ],
  [
    `Делегация событий`,
    `Позволяет не создавать кучу функций обработчиков для каждого элемента а создать 1 обработчик для родительского элемента и в нем описывать логику для каждого e.target. Все это возможно благодаря всплытию события (bubbling)`
  ],
  [
    `Распространение событий (propagation)`,
    `Изначально любое событие по дефолту идет от document до целевого элемента на котором оно произошло, а затем идет вверх (bubbling), т.е. идет от target и поднимается вверх через родительские элементы до самого body. Если в обработчик передать 3 параметр true то событие будет идти по нисходящей - от родителя к target (capturing).`
  ],
  [
    `.stopPropagation()`,
    `Метод события который останавливает распространение(всплытие)`
  ],
  [
    `Функция высшего порядка`,
    `Ф-ция которая либо принимает другую ф-цию в виде аргумента либо возвращает ф-цию (map, foreach...)`
  ],
  [
    `switch()`,
    `Конструкция сравнения нескольких значений переданного аргумента<pre>
switch(x) {
case 1: {

}
break;
default: {

}
break;
}</pre><hr>А так выглядит группировка нескольких значений<pre>
switch(x) {
case 1:
case 2: {
  console.log('1 or 2');
}
break;
default: {

}
break;
}</pre>`
  ],
  [
    `.before()`,
    `Метод элемента позволяет вставить перед ним другой элемент или строку переданную в аргумент`
  ],
  [
    `.after()`,
    `Метод элемента позволяет вставить после него другой элемент или строку переданную в аргумент`
  ],
  [
    `.preventDefault()`,
    `Метод события позволяет отключить стандартное поведение элемента на котором событие произошло`
  ],
  [
    `Погружение и всплытие в событиях`,
    `При срабатывании какого либо события оно сначала движется от корневого элемента до элемента на котором оно сработало а потом всплывает наверх. При использовании стандартного обработчика события addEventListener без 3 параметра события вызываются по всплытию. Но если указать 3 параметр true события будут вызываться в порядке погружения (capture)<pre>
&lt;div&gt;
&lt;button&gt;Click&lt;/button&gt;
&lt;/div&gt;

document.querySelector('div').addEventListener('click', () => alert('div'));
document.querySelector('button').addEventListener('click', () => alert('button'));</pre>Например здесь при клике на кнопку сначала сработает button потом div. Но если передать 3 аргумент в обработчик с true порядок вызова измениться`
  ],
  [
    `.substr(x, y)`,
    `Метод строки обрезает текущую строку с x символа(number) y символов и возвращает новую строку`
  ],
  [
    `Объединение массивов`,
    `const ar2 = [].concat(ar1); - 1 способ. Метод concat в старых версиях сначала проверял получаемый объект на isArray и потом применял rest оператор для слияния массивов. В ES6+ теперь проверяет у массива наличие св-ва Symbol.isConcatSpreadable и если оно true объединяет сущности<hr>const ar3 = [...ar1, ...ar2, 'some']; - 2 способ через спред оператор`
  ],
  [
    `hashchange`,
    `Событие объекта window происходит когда меняется hash в адресной строке (window.location.hash)`
  ],
  [
    `.isEqualNode(x)`,
    `Метод элемента позволяет проверить равен ли элемент на котором вызван метод элементу переданному в виде аргумента`
  ],
  [
    `.nodeValue`,
    `Свойство узла позволяющее получить контент. При вызове напрямую на элемента возвращает null. Чтобы получить контент содержащийся внутри элемента необходимо обратиться к его первому дочернему узлу - <b>el.childNodes[0].nodeValue</b>. Такая запись эквивалента - el.textContent. Свойство удобно использовать при сравнении элементов когда необходимо перерендерить только часть интерфейса`
  ],
  [
    `document.createRange()`,
    `Метод возвращает объект типа Range который по сути является интерфейсом представляющим фрагмент. Сам фрагмент по сути является подобием ноды оболочки который так же может содержать другие ноды. При вставке на страницу пропадает вставляя лишь содержимое<hr>
    <b>document.createRange().createContextualFragment(x)</b> - создает фрагмент и наполняет его html разметкой которая представленна в переменной х`
  ],
  [
    `Мемоизация`,
    `Это подход который запоминает вычисления каких то ф-ций и при последующем вызове уже не тратит ресурсы на новые вычисления а выдает запомненный результат если аргументы не изменились<pre>
    const memo = (f) => {
      let result = new Map();

      return (...args) => {
        if (!result.has(args.toString())) {
          result.set(args.toString(), f(...args));
        }
        return result.get(args.toString());
      }
    }
    const add = (x, y) => x + y;
    const memoAdd = memo(add);
    memoAdd(2, 5); // 7
    memoAdd(2, 5); // 7</pre>Пример универсального мемоизатора ф-ций с помощью замыкания. При 1 вызове мемоизированной ф-ции происходит вычисление и запись в коллекцию. При последующих вызовах если аргументы не изменились возвращается значение из коллекции тем самым экономя ресурсы`
  ],
  [
    `Замыкание`,
    `Это ф-ция которая запоминает свои внешние переменные и имеет к ним доступ. В JS по сути все ф-ции являются замыканием. Предназначено для изоляции переменной(ых) внутри области видимости функции<pre>
const memo = (f) => {
let result = new Map();   <sup>1</sup>

return (...args) => {     <sup>2</sup>
  if (!result.has(args.toString())) {
    result.set(args.toString(), f(...args));  <sup>3</sup>
  }
  return result.get(args.toString());
}
}
const add = (x, y) => x + y;
const memoAdd = memo(add);
memoAdd(2, 5); // 7
memoAdd(2, 5); // 7   <sup>4</sup></pre>Здесь мы создали мемоизатор ф-ции.<br>
1)Создаем новый экземпляр коллекции<br>
2)Возвращаем ф-цию которая в свою очередь возвращает значение из коллекции. При замыкании мы всегда должны возвращать вложенную ф-цию не важно стрелочная, анонимная или какая то еще<br>
3)Если в колеекции нет ключи представленного в виде строки переданных агрументов то создаем новый ключ где значением будет вычисление ф-ции которую передали в качестве аргумента. Т.к. это универсальный мемоизатор то мы не знаем сколько аргументов было передано поэтому используем деструктуризацию массива с аргументами<br>
4)При 2 вызове ф-ции значение уже берется из коллекции<br>
Общий принцип таков что каждый раз вызывая мемоизированную версию любой ф-ции срабатывает вложенная ф-ция. В ней происходит проверка имеет ли коллекция какой то ключ. Сначала интерпритатор JS ищет эту коллекцию в области видимости вложенной ф-ции. Когда он ее не находит то поиск продолжается во внешней области. Так может продолжаться пока не дойдет до глобальной области видимости. В итоге коллекция находится на внешней области и мы производим с ней некоторые операции. Эта область видимости будет существовать до сих пор пока на нее ссылается вложенная ф-ция поэтому при каждом вызове мемоизированной ф-ции мы работаем не с новой коллекцией а с той что уже была создана или модифицированна.<br>
<b>Если говорить еще проще то по сути мы имеем какую то ф-цию обертку в которой объявляем переменные которые хотим изолировать а затем возвращаем какую то ф-цию с логикой которая производит какие то операции с нашей(ими) переменной(ыми)</b>`
  ],
  [
    `.padStart(x, y) || .padEnd(x, y)`,
    `Методы строки позволяют добавить к строке символы - y в начало || в конец строки пока длина всей строки не будет равна x`
  ],
  [
    `Оператор нулевого слияния (??)`,
    `<b>const a = 0 ?? 'string'; => 0</b> - оператор похож на логическое или(||), но возвращает первое значение если оно не null и не undefined. Разница между ними в том что ?? может возвращать логическое не (0, '', false)`
  ],
  [
    `typeof`,
    `<b>const a = typeof 'text';</b> - оператор возвращает текстовое значение типа. По скольку для объектов и массивов будет возвращать 'Object' то его задача отделять примитивы от более сложных структур`
  ],
  [
    `.every()`,
    `Метод массива проверяет каждый элемент на истину где условие описывается в callback. Вернет true если массив пустой или все элементы удовлетворяют условию`
  ],
  [
    `Условный доступ и условный вызов`,
    `<pre>
const a = { b: null };
a.b?.c = 4;</pre>В данном примере используется условный доступ к св-ву объекта. Оператор ? проверяет выражение слева на null/undefined и если это так прекращает проверку и вернет undefined<pre>
someFunction?.();</pre>Здесь происходит условый вызов ф-ции. Если ф-ции не существует то ошибки не будет. Однако если someFunction не ф-ция мы получим ошибку TypeError потому что условный оператор не проверяет тип и лишь сравнивает с null/undefined`
  ],
  [
    `Деструктуризация`,
    `позволяет разложить обьект или массив сразу на переменные.<hr><pre>
const [a, , b, c = 4] = array;</pre>Деструктуризация массива где мы получаем переменные a b c которые соответствуют элементам массива в том порядке в котором мы их обьявили. При этом если с в массиве не существует то по умолчанию ей присвоится значение 4<br>
<b>const [a, ...b] = 'hello';</b> - при деструктуризации массива справа может быть любой итерируемый объект<pre>
const {name: newVar, age: newAge = 12} = object;</pre>Деструктуризация объекта где для имен переменных мы переименовываем свойста обьекта, а также если age не задан ему будет присвоено значение 12.<br>
<b>const {floor: anotherName} = Math;</b> - деструктуризация объекта с вынесением метода в переменную anotherName. Если у объекта нет такого свойства то значением в переменной будет undefined`
  ],
  [
    `.target`,
    `свойсто объекта события(event) возвращающее элемент на котором произошло событие`
  ],
  [
    `Правила оценки алгоритмов`,
    `1) всегда выбирается наихудший вариант<br>
    2) учитывается только зависимость операций от кол-ва входных данных<br>
    3) при оценивании совокупности алгоритмов остается только самый медленный`
  ],
  [
    `Методы сортировки массива`,
    `<b>Пузырьковая сортировка</b><pre>
function sort(arr) {
  for(let i = arr.length - 1; i > 0; i--) {
    for(let j = 0; j < i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}</pre>Принцип сортировки таков - проходим по массиву несколько раз, при этом каждый раз берем первые 2 элемента и сравниваем их. Наибольший элемент смещаем к концу массива а затем сравниваем следующую пару элементов. В итоге после каждого прохода у нас в конце будет оставаться самый большой элемент. Сложность сортировки O(n*n)<hr>
<b>Выборочная сортировка</b><pre>
function sort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i;
    for (let j = i + 1; j < arr.length; j++) {
      min = arr[min] < arr[j] ? min : j;
    }
    [arr[i], arr[min]] = [arr[min], arr[i]];
  }
}</pre>
Принцип таков - делаем несколько проходов по массиву и каждый раз находим наибольший или наименьший элемент и помещаем его в конец или в начало массива. В 1 цикле мы не доходим до конца массива т.к. вложенный цикл будет проходить со смещением +1. Сложность O(n*n)<hr>
<b>Сортировка вставками</b><pre>
function sort(arr) {
  for (let i = 1; i < arr.length; i++) {
      const current = arr[i];
      let j = i;
      while (j > 0 && arr[j - 1] > current) {
          arr[j] = arr[j - 1];
          j--;
      }
      arr[j] = current;
  }
  return arr;
};</pre>
Последовательно берет каждый элемент массива и сравнивает с элементами левой части от себя. Таким образом как бы ищет место элементу в левой части которая уже является отсортированной<hr>
Вышеупомянутые способы сортировки хорошо подходят если имеется массив с почти отсортированными данными, в противном случае для более эффективной работы можно прибегнуть к алгоритмам ниже<hr>
<b>Сортировка слиянием</b><br>
<img src="./img/union_sort.png" style="width: 500px"><br>
Сначала массив делится на равные части, затем еще раз и еще раз пока в каждой части не останется по 1 элементу. Затем массивы сравниваются по нулевому индексу и тот кто меньше уходит в объедененный массив и так продолжается пока в конечном счете не останется 1 массив. Сложность O(nlog(n))<pre>
function merge(ar1, ar2) {
  const result = [];
  while(ar1.length && ar2.length) {
    if (ar1[0] === ar2[0]) {
      ar1.shift();
      result.push(ar2.shift());
    } else {
      result.push(ar1[0] > ar2[0] ? ar2.shift() : ar1.shift());
    }
  }
  return [...result, ...ar1, ...ar2];
}
function sort(arr) {
  if (arr.length === 1) return arr;
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);
  return merge(sort(left), sort(right));
}</pre><hr>
<b>Быстрая сортировка</b><pre>
function quick(arr) {
  if (arr.length <= 1) return arr;
  const left = [], right = [];
  const pivot = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > pivot) {
      right.push(arr[i]);
    } else {
      left.push(arr[i]);
    }
  }
  return [...quick(left), pivot, ...quick(right)];
}</pre>Принцип таков - сначала берем рандомный элемент(например 1), и затем последовательно сравниваем его с каждым другим элементами и затем распределяем элементы массива те что меньше первого в массив left, те что больше в right. После чего возвращаем объедененный массив где сначала рекурсивно прогоняем также left и right массивы. Обычно временная сложность такого алгоритма O(nlogn). Но если передать отсортированный массив или почти отсортированный то тогда сложность будет уже O(n*n) потому что вместо разделения массива на части мы получим просто вложенный цикл`
  ],
  [
    `.currentTarget`,
    `свойсто объекта события(event) возвращающее элемент на котором сработал обработчик события`
  ],
  [
    `document.createDocumentFragment()`,
    `Создает оболочку контейнер для каких то элементов для последующей вставки в другой элемент. При вставке сам фрагмент исчезает, остаются лишь дочерние элементы`
  ],
  [
    `.offsetWidth`,
    `Свойство элемента позволяет получить его полную ширину включая border и padding`
  ],
  [
    `.cloneNode()`,
    `Копирует элемент. Если в аргумент метода передан true то также копирует и дочерние элементы`
  ],
  [
    `.closest(x)`,
    `Метод элемента возвращает первый родительский или сам элемент по селектору х. Работает подобно querySelector только не вниз а вверх`
  ],
  [
    `Array.from()`,
    `Преобразует псевдомассив или массивоподобный объект в массив. В качестве аргумента принимает 1 обязательный - объект и 2 необязательный - callback который позволяет как то обработать каждый элемент<br><b>Array.from([1,2,3], x => x + x) => [2,4,6]</b><hr>
    <b>const arr = Array.from({length: count}, () => 'x');</b> - также можно создавать массивы передав объект со свойстом length и callback который будет возвращать какое то значение для дальнейшего подставления в массив`
  ],
  [
    `.querySelector()`,
    `Поиск по DOM дереву определенного элемента.<hr>'input[checked]' - делает выборку полей выбранных именно при разметке страницы<hr>'input:checked' - делает выборку полей выбранных уже в процессе какого то взаимодействия`
  ],
  [
    `Работа со стилями`,
    `<b>el.style.x = y</b> - такая запись позволяет добавить inline стиль элементу. х - свойство которое указывает на CSS свойство где вместо - используется camelCase (fontSize), а у значение свойства<br>
    <b>const color = el.style.color;</b> - также можно получить значение свойства но только если оно указано в inline стилях<hr>
    <b>el.getComputedStyle().x</b> - позволяет получить любое CSS свойство элемента НО уже вычисленное на этапе отрисовки.`
  ],
  [
    `window.page?Offset`,
    `Свойство объекта window, указывает на сколько пикселей прокручен документ по вертикали(У) или горизонтали(Х)`
  ],
  [
    `window.scrollTo(x, y, z)`,
    `Метод объекта window позволяет прокрутить документ до координат х, у. z - объект настроек где можно например указать плавность прокрутки<br>
    <b>.scrollTo(0, 500);</b> - без настроек<br>
    <b>.scrollTo({left: 0, top:0, behavior: 'smooth' })</b> - при использовании настроек все параметры передаются в объекте`
  ],
  [
    `.scrollIntoView()`,
    `Метод элемента позволяет прокрутить документ до элемента на котором вызван метод. Принимает в виде аргумента объект настроек - ({ behavior: 'smooth' })`
  ],
  [
    `Передача аргументов в функцию обработчик`,
    `1 вариант создать функцию в которой будет вызываться другая функция с переданными аргументами<pre>
  btn.addEventListener('click', () => myFunc('text'));</pre>
  2 вариант с помощью привязки контекста указать аргументы и в самой функции использовать сам контекст (если аргумент 1) или использовать массив с аргументами. В таком случае функция не может быть стрелочной т.к. теряется контекст<pre>
  btn.addEventListener('click', myFunc.bind('text'));
  myFunc() {
    console.log(this);
  }</pre>`
  ],
  [
    `Разница событий mouseover/mouseout и mouseenter/mouseleave`,
    `Разница в том что у 2 варианта нет распространения события и оно не может использоваться в делегировании`
  ],
  [
    `.getBoundingClientRect()`,
    `Метод элемента возвращает объект с информацией об элементе. Через свойства объекта можно получить его размеры и позиционирование относительно viewport`
  ],
  [
    `Работа с атрибутами элемента`,
    `<b>img.src = url;</b> - стандартные атрибуты элемента доступны через свойства объекта<br>
    <b>el.setAttribute('my', '123');</b> - метод позволяет задать любой атрибут элементу<br>
    <b>el.getAttribute('my');</b> - позволяет получить значение любого атрибута элемента<br>
    !!! При получении пути элемента (src, href) через свойство объекта он всегда будет полный, а при получении через метод он будет таким как указан в разметке`
  ],
  [
    `.querySelectorAll()`,
    `Поиск по DOM дереву всех элементов переданных в аргумент. Возвращает псевдомассив. Чтобы воспользоваться обычными методами массива можно преобразовать полученный результат в массив => <b>const ar = [...document.querySelectorAll('div')];</b>`
  ],
  [
    `.getElementsBy...`,
    `Метод элемента позволяет выбрать несколько элементов на основе селектора. Возвращает live HTMLCollection. Это значит что при удалении или добавлении выбранных элементов этот список также будет меняться`
  ],
  [
    `.setAttribute()`,
    `Позволяет установить атрибут элементу. Пример - <br><pre>
el.setAttribute('style', 'background: red;');</pre>`
  ],
  [
    `.test(r)`,
    `Метод строки возвращает bool если строка имеет или нет вхождение поиска`
  ],
  [
    `Видимость документа`,
    `У объекта document есть св-во visibilityState которое содержит visible - когда документ виден(мы находимся на текущей вкладке) и hidden - когда документ не видно(при переключении на другую вкладку). Для отслеживания изменения состояния видимости можно подписаться на событие документа - <b>'visibilityChange'</b>`
  ],
  [
    `window.getComputedStyle(e)`,
    `Возвращает объект с вычисленными свойствами CSS (даже те что не указаны явно) элемента - e. Все свойста при этом readonly а также все относительные величины становятся фиксированными`
  ],
  [
    `WebSocket`,
    `Веб сокеты позволяют поддерживать непрерывную связь с сервером а также обмениваться сообщениями<br>
    <b>const ws = new WebSocket('wss://...');</b> - создание веб сокета<br>
    <b>ws.send(someData);</b> - отправка сообщений на сервер<br>
    Чтобы получать сообщения с сервера необходимо зарегистрировать обработчик событий для экземпляра web socket на событие message`
  ],
  [
    `.elementFromPoint(x, y)`,
    `Метод объекта document возвращающий найденный элемент по координатам х и у`
  ],
  [
    `AbortController`,
    `<pre>
const abort = new AbortController();
fetch(url, { signal: abort.signal });
abort.abort();</pre>Контроллер для отмены запроса. Сначала создается новый экземпляр а затем передается в запрос в качестве параметра signal само свойство signal контроллера. Теперь при необходимости можно вызвать метод .abort() чтобы отменить запрос`
  ],
  [
    `.some()`,
    `Метод массива проверяющий подходит ли хоть 1 элемент условию переданному в callback. `
  ],
  [
    `Object.entries(a)`,
    `Принимает объект в виде аргумента и возвращает его уже в виде массива с массивами - [['prop1', 'value1'], ['prop2', 'value2']]`
  ],
  [
    `.getAttribute()`,
    `Возвращает значение атрибута элемента, переданного через аргумент метода.`
  ],
  [
    `.classList`,
    `Позволяет оперировать классами на целевом элементе<br>add() - добавить<br>remove() - удалить<br>toggle() - сменить<hr>Если сначала нужно удалить класс а затем его восстановить то между этими операциями нужно произвести какие то изменения с элементом иначе браузер проигнорирует эти операции. Пример:<pre>
el.classList.remove('some-class');
el.offsetWidth = el.offsetWidth;
el.classList.add('some-class');</pre><hr>el.classList.item(n) - позволяет получить n - элемент из массива классов`
  ]
];
