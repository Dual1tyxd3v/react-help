/* eslint-disable quotes */
const Css = [
  [
    `text-align`,
    `Выравнивает содержимое внутри контейнера по горизонтали(устаревший метод)`
  ],
  [
    `filter`,
    `Свойство позволяет применить к элементу различные графические эффекты (blur, brightness, drop-shadow...)`
  ],
  [
    `object-fit`,
    `Свойство подобно background-size позволяет указать как медиа элемент(img video) будут заполнять область`
  ],
  [
    `accent-color`,
    `Свойство позволяет задать цвет фона некоторым элементам формы при условии что они выбраны (checked) - input с type = radio, checkbox, range а также progress`
  ],
  [
    `Выборка с исключением`,
    `<b>$('x:not(y)')</b> - Выборка элементов х но только тех что не подходят условиям в у. Например - $('a:not(a[href])') - выбрать все элементы a у которых нет атрибута href<br><b>$(x).not(y)</b> - аналогичная запись. Например - $('a').not('a[href]')`
  ],
  [
    `Выборка прямого потомка`,
    `<b>.div > *</b> - позволяет выбрать всех прямых потомков(*) или можно указать более конкретно`
  ],
  [
    `Graceful degradation`,
    `Способность системы поддерживать минимально необходимую функциональность. В веб разработке это подход замены некоторых элементов на более старые аналоги для корректной работы в старых браузерах или же скрытие некоторых элементов без вреда для функциональности для устройств с меньшим экраном. Если еще короче то это разработка от сложного к простому (desktop first)`
  ],
  [
    `Progressive enhancement`,
    `Подход когда при необходимости добавляются новые элементы интерфейса без вреда для функциональности. Разработка от простого к сложному(mobile first)`
  ],
  [
    `::selection { ... }`,
    `Глобальный псевдоэлемент позволяет стилизовать выделение текста на странице`
  ],
  [
    `:root { ... }`,
    `Глобальный псевдокласс позволяет задать глобальные стили. Тоже самое что и стилизация html селектора но специфичность выше`
  ],
  [
    `Переменные в CSS`,
    `Переменные можно использовать только в области видимости или у дочерних элементов поэтому их обычно определяют в :root<br>
     <b>--color-black: #000;</b> - определение переменной<br>
     <b>color: var(--color-black);</b> - использование переменной`
  ],
  [
    `@supports`,
    `Директива позволяет указать что если браузер поддерживает какое то свойство то применятся стили внутри блока кода<pre>
    p {
      color: red;
      @supports(background-clip: text) {
        background-clip: text;
      }
    }</pre> В условии нужно полностью описывать и свойство и значение`
  ],
  [
    `Медиа запросы`,
    `Позволяют указать определенные стили в зависимости от конкретных условий в запросе. Можно указать размеры экрана, плотность пикселей, а также возможность инициировать некоторые состояния<br>
    <b>@media (max-width: 500px) { ... }</b> - описание стилей для устройств с экраном меньше 500px<br>
    <b>@media (min-resolution: 192dpi) and (min-width: 600px), (min-width: 1200px) { ... }</b> - комбинирование медиа запросов. Означает что если экран ретина И минимальная ширина экрана 600px ИЛИ просто минимальная ширина экрана 1200px то стили в блоке кода будут применены<br>
    <b>@media (hover: none) { ... }</b> - позволяет указать стили для устройств которые не могут инициировать состояние hover (планшеты, телефоны) (значение hover имеет обратный эффект)`
  ],
  [
    `Выборка следующего элемента`,
    `<b>div + p</b> - позволяет выбрать следующий соседний элемент на одном уровне вложенности и с одним родителем`
  ],
  [
    `Выборка всех элементов на этом же уровне вложенности`,
    `<b>div ~ p</b> - позволяет выбрать все элементы на этом же уровне вложенности у которых тот же родитель что и у целевого элемента`
  ],
  [
    `shape-outside`,
    `Свойство позволяет задать элементу не прямоугольную форму, благодаря этому inline элементы обтекают этот элемент по форме. Но такой элемент должен иметь размеры`
  ],
  [
    `perspective: x`,
    `Свойство позволяет указать расстояние между осью Z и пользователем, где х число в ед измерения размеров. Свойство полезно при использовании различных анимаций`
  ],
  [
    `background-blend-mode`,
    `Свойство позволяет указать как фоновое изображение будет взаимодействовать с фоновым цветом`
  ],
  [
    `box-decoration-break`,
    `Свойство позволяет указать как будут отображаться фрагменты элемента при переносе строки<br>
    <img src="./img/box-dec-slice.jpg" /><br>
    <b>slice</b> - в данном случае текст просто переносится без особых оформлений<br>
    <img src="./img/box-dec-clone.jpg" /><br>
    <b>clone</b> - а в этом случае стили для всей строки применяться к каждому фрагменту`
  ],
  [
    `Вендорные префиксы`,
    `Специальная приставка для свойств которые не внедренны в браузер (-moz-opacity)`
  ],
  [
    `Блочная модель элемента`,
    `Правила по которым браузер определяет размеры элемента. Внешний отстут, рамка, внутренний отступ, размер контента.`
  ],
  [
    `Специфичность селекторов`,
    `Это градация приоритета стилей элемента<br>1. inline - 1000<br>2. id - 100<br>3. class/attr/: - 10<br>4. элемент/:: - 1`
  ],
  [
    `Варианты добавления CSS на сайт`,
    `1. Инлайн стили внутри самого тега (style, переопределение такого стиля возможно только с использованием !important)<br>2. Глобальные стили внутри тега head через тег &lt;style&gt;<br>3. Внешний файл стилей через link<br>4. Импорт внутри файла стилей`
  ],
  [
    `Процесс обработки значений в конечное`,
    `1. Сначала идет загрузка значений из CSS и решение конфликтов<br>
    2. Элементам у которых должно быть значение и которые не были описаны в CSS назначаются стандартные значения браузера<br>
    3. Оставшимся элементам присваивается начальное состояние значения(например padding: 0)<br>
    4. Относительные единицы переводятся в px (em, rem)<br>
    5. % переводятся в px<br>
    6. На основе всех полученных значений происходит последний расчет где все не целые значения округляются`
  ],
  [
    `Расчет относительных единиц`,
    `<b>font-size: %</b> - высчитывается от родительского шрифта(в случае html от стандартного шрифта браузера)<br>
    <b>font-size: em</b> - высчитывается от родительского шрифта<br>
    <b>font-size: rem</b> - высчитываетсяо от шрифта в html или от стандартного браузерного(16px)<br>
    <b>width/height: %</b> - высчитываются от ширины родителя<br>
    <b>width/height: em</b> - высчитываются от шрифта текущего элемента`
  ],
  [
    `Порядок парсинга сайта`,
    `1. Загрузка html<br>
    2.1. Парсинг html<br>
    2.2. Загрузка css<br>
    3.1. Построение DOM дерева<br>
    3.2. Парсинг css:<br>
    3.2.1. Разрешение конфликтов<br>
    3.2.2. Высчитывание конечных значений свойств<br>
    4. Построение CSS DOM<br>
    5. Отрисовка дерева<br>
    6. Отрисовка сайта<br>
    7. Вывод результата`
  ],
  [
    `Как наследуются значения в CSS`,
    `Так как у большинства свойств должны быть определены значения то они определяются следующим образом в случае наследования:<br>
    1. Указано ли значение в стилях? Если да то значение берется оттуда<br>
    2. Если нет то проверяется может ли свойство наследоваться. Если да то значение берется из родительского элемента. Если нет то устанавливается стандартное значение браузера или начальное состояние<br>
    (Свойства относящиеся к тексту наследуемые, остальные в основном нет, но стоит проверять)`
  ],
  [
    `mask`,
    `Позволяет создать шаблон из изображения по которому затем будет создан фон заданного цвета. Т.к. свойство достаточно новое для многих браузеров требуется префикс<br>
    <b>mask-image</b> - задает изображение для маски<br>
    <b>mask-size</b> - задает размер изображения`
  ],
  [
    `currentColor`,
    `Это значение подходит для свойств определяющих цвет. Оно по сути является ссылкой на значение color текущего элемента или родителя`
  ],
  [
    `:has(x)`,
    `Позволяет задать стилистику элементу который содержит х, где х другой элемент. Полезно если необходимо изменить родительский элемент при изменении состояния дочернего элемента`
  ],
  [
    `grid`,
    `Позволяет создать разметку в виде сетки<br>
    <b>grid-template-rows: a b c </b> - задает количество строк в сетке(зависит от количества переменных) размером a b c<br>
    <b>grid-template-columns: a b c</b> - задает количество колонок заданного размера
    <b>grid-template-...: repeat(x, y)</b> - функция repeat позволяет создать одинаковые колонки/строки где х количество а у размеры<br>
    <b>grid-template-...: [startBlock] 1fr [endBlock startText] 2fr [endText]</b> - такая запись позволяет именовать линии и в последующем обращаться к ним уже по имени<br>
    <b>grid-template-...: repeat(2, [box-st] 1fr [box-end])</b> - именование линий в repeat. Чтобы избежать конфликта имен к ним автоматически в конце добавиться итератор (box-st 1)<br><pre>
grid-template-areas: 'head head head head'
                     'box1 box2 box3 side'
                     'main main main side'
                     'foot foot foot foot';

div {
  grid-area: head;
}</pre>позволяет создать что то вроде карты именованных ячеек и затем просто подставлять их нужным элементам. Удобно для небольших проектов. При указании . вместо имени будет создана пустая ячейка<br>
    <b>grid-template-...: repeat(auto-fill, x)</b> - берет все свободное место и делит его на размер - х и в итоге создает максимально возможное количество ячеек. При этом если элементов будет меньше чем ячеек то в конце остануться пустые ячейки<br>
    <b>grid-template-...: repeat(auto-fill, x)</b> - тоже что и выше но при наличии пустых ячеек они схлопываются. Благодаря такому поведению можно создавать адаптивные сетки -
    <b>grid-template-...: repeat(auto-fill, minmax(200px, 1fr))</b>
    <hr>
    <b>grid-gap</b> - задает одинаковые отступы между колонками и строками<br>
    <b>grid-row-gap</b> - задает отступы между строками<br>
    <b>grid-comlumn-gap</b> - задает отступы между колонками<hr>
    <b>grid-x-start</b> - указывает с какой линии элемент должен начать заполнение ячеек (х - row/column)<br>
    <b>grid-x-end</b> - указывает на какой линии элемент должен закончить заполнение в сетке<br>
    <b>grid-x: a / b</b> - короткая запись предыдущих 2 записей, где х - row/column, a начальная линия, b конечная<br>
    <b>grid-x: a / span b</b> - такая запись позволяет указать начальную линию и b - количество ячеек которые должен занять элемент<br>
    <b>grid-x: a / -1</b> - позволяет элементу занять все ячейки начиная с начальной (а) и до самой последней<br>
    <b>grid-area: x / y / a / b</b> - еще более короткая линия позволяет сразу указать линии по строкам и кололнкам, где x начальная по строкам, у начальная по колонкам, a конечная по строкам, b конечная по колонкам<br>
    <hr>
    Если элементы не влезают в заданую сетку то они переносятся в автоматически созданную неявную сетку. Для стилизации неявной сетки используются:<br>
    <b>grid-auto-flow: x</b> - указывает каким образом добавлять неявную сетку, в виде столбцов или строк где х - row/column (по умолчанию row)<br>
    <b>grid-auto-flow: x dense</b> - dense в данном случае указывает что в сетке не должно быть дыр которые могут появится в случае выравнивания<br>
    <b>grid-auto-rows: x</b> - позволяет задать размер строки неявно созданной сетки<br>
    <b>grid-auto-column: x</b> - задать размер колонки неявно созданной сетки
    <hr>
    Выравнивание:<br>
    <b>align-items</b> - выравнивает элементы внутри ячеек/областей по вертикали<br>
    <b>justify-items</b> - выравнивает элементы внутри ячеек/областей по горизонтали<br>
    <b>align-self</b> - выравнивает конкретный элемент по вертикали<br>
    <b>justify-self</b> - выравнивает конкретный элемент по горизонтали<br>
    !По умолчанию стоит значени stretch!<br>
    <b>justify-content</b> - выравнивание по горизонтали всего трека(строка/столбец)<br>
    <b>align-content</b>- выравнивание по вертикали всего трека(строка/столбец)<br>
    !В случае выравнивания элемент может занять чью то ячейку и тот элемент чье место заняли будет сдвинут в приоритете так чтобы не нарушить порядок как указан в разметке и такое поведение может создать пустую ячейку!
    <hr>
    Единицы применяемые в гридах помимо стандартных:<br>
    <b>fr</b> - фракция обозначает часть свободного пространства. (пример - 1fr 2fr 1fr - поделит свободное место на 4 части где 1 элемент займет 1/4, 2 1/2 и 3 1/4)<br>
    <b>min-content</b> - ячейка займет минимальный размер под контент, при этом слова будут переносится<br>
    <b>max-content</b> - ячейка займет минимальный размер под контент но без переноса слов<br>
    <b>minmax(x, y)</b> - ячейка будет занимать от х до у размеры, но по возможности будет использовано наибольшее значение
    <hr>
    Как происходит заполнение ячеек элементом если элемент пытается занять ячейку где уже есть другой элемент:<br>
    1) если находящийся в ячейке элемент не имеет явного позиционирования в ней то он сдвигается в неявную сетку<br>
    2) если находящийся в ячейке элемент явно спозиционирован там то 2 элемент просто перекроет его сверху`
  ],
  [
    `:last-of-type`,
    `Позволяет выбрать последний элемент на основе целевого селектора из всех дочерних элементов своего родителя`
  ],
  [
    `Парсинг CSS и разрешение конфликтов`,
    `1. Сначала идет рассмотрение приоритета CSS правил:<br>
    I. Свойства с атрибутом !important<br>
    II. Свойства описанные в CSS<br>
    III. Браузерные стандартные свойства<hr>
    2. Затем если конфликт не разрешен используется специфика селекторов:<br>
    I. inline стили
    II. селектор id<br>
    III. селектор class/pseudo/по атрибуту<br>
    IV. селектор по тэгу<br>
    в итоге получается что то вроде такой записи - x.x.x.x и затем они сравниваются в случае конфликта по очередно каждую цифру слева направо. Как только в 1 из вариантов число оказывается больше чем у других сравнение останавливается и выбирается значение свойства из этого правила.<pre>
button.button {
color: red;
}
div#div .button {
color: black;
}</pre>В данном случае спецификация 1 варианта будет - 0.0.1.1 а 2 - 0.1.1.1 и приоритет будет выше у 2 варианта<hr>
3. Если конфликт остается не разрешен то в приоритете будет то правило что было загруженно последним<br>
Общий селектор * имеет 0 спецификацию`
  ],
  [
    `display: flex`,
    `justify-content: * - выравнивание элементов по горизонтали если направление по оси Х или по вертикали если Y.
    <hr>
    align-item: * - выравнивание по вертикали если направление по Х и по горизонтали если по Y.
    <hr>
    * - <br>
    flex-start - по левой/верхней стороне<br>
    flex-end -  по правой/нижней стороне<br>
    center - по центру<br>
    space-between - создает одинаковые отступы между элементами<br>
    space-around - делает отступы вокруг элементов из свободного пространства(по бокам выходит меньше потому что равны 0.5 от межблочных отступов)<br>
    space-evenly - распределяет свободное пространство для отступов вокруг элементов по ровну<br>
    stretch - растягивает элементы
    <hr>
    flex-direction - направление расположения элементов<br>
    row - справа налево (по default)<br>
    row-reverse - слева направо<br>
    column - сверху вниз<br>
    column-reverse - снизу вверх
    <hr>
    order - задает порядок элементов. По default = 0, 1 - сдвигает вправо, -1 влево.
    <hr>
    align-self - задает положение только для 1 элемента
    <hr>
    flex-wrap - обертка где:<br>
    nowrap - размеры элементов автоматически подгоняются для установки в 1 ряд<br>
    wrap - переносит элементы что не влезли<br>
    wrap-reverse - перенос с реверсом
    <hr>
    flex-flow - объединяет direction и wrap в 1 свойстве (flex-flow: column wrap)
    <hr>
    align-content - распределяет свободное пространство между и вокруг флекс элементов по оси Y
    <hr>
    flex-basis - задает ширину флекс элемента. Тоже самое что и width
    <hr>
    flex-grow - указывает как элемент относительно других будет поглощать свободное пространство (по умолчанию 0)
    <hr>
    flex-shrink - указывает поведение элемента при уменьшении размера контейнера. При 1 элемент будет уменьшаться при 0 будет оставаться заданого размера`
  ],
  [
    `margin`,
    `Если у 2 элементов имеются отступы направленые друг к другу, то выберется тот что больше. Это называется
    схлопыванием.
    <hr>
    Обычно задается справа налево или сверхну вниз. Связано с тем что принято что блок не может двигать сам
    себя, а его двигает сосед (*-bottom, *-right).
    <hr>
    : 0 auto - выравнивание блока по горизонтали если задана ширина.
    <hr>
    В случае отрицательного значения соседние элементы будут считать что размер элемента уменьшен на это значение и будут как бы залазить на него, но при этом сам размер элемента не меняется
    <hr>
    Если применить auto к 1 из сторон по бокам то элемент будет смещен в противоположную сторону, а все свободное пространство будет распологаться с указанной стороны тем самым создавая эффект space-between между целевым и последующими элементами`
  ],
  [
    `display: table-cell`,
    `Указывает элементу что он является ячейкой таблицы, при этом родительский элемент должен быть display: table. Удобно если нужно выстроить рядом несколько блоков и чтобы они были одной высоты`
  ],
  [
    `Единицы изменения`,
    `em - единица измерения на основе font-size. (1em = font-size). Подходит для позиционирования.
    <hr>
    rem - единица всегда равна 16px
    <hr>
    vh - равна высоте размера экрана
    <hr>
    vw - равна ширине размера экрана + скроллбар`
  ],
  [
    `box-shadow`,
    `задает тень блоку.<br>
    : 0px 4px 4px rgba(0, 0, 0, 0.25) - где 1 отклонение по Х относительно блока, 2 по Y, 3 радиус размытия, 4 цвет.`
  ],
  [
    `clip-path`,
    `Свойство позволяет выделить у элемента видимую часть в виде какой либо фигуры<br>
    <b>clip-path: *function(x)</b> - function определенная функция для отрисовки фигуры а х координаты или размеры в зависимости от ф-ции. Все координаты указываются относительно левого верхнего угла<br>
    <b>circle(50%)</b> - отрисовка круга<br>
    <b>ellipse(x y a b)</b> - овал где х - ширина по х, у - высота по у, a - смещение от левого угла по х, b - смещение от верхнего угла по у<br>
    <b>pollygon(x y, x y, x y, ...)</b> - отрисовка многоугольника где х у координаты углов фигуры. Минимум необходимо 3 точки<br>
    <b>path(x)</b> - отрисовка сложной фигуры где х задается также как path в svg`
  ],
  [
    `transform`,
    `<b>translateY(*px)</b> - сдвигает элемент на * пикселей по вертикали.<br>
    <b>translateX(*px)</b> - сдвигает по горизонтали<br>
    <b>translate(*px, *px)</b> - комбинированная запись где 1 по Х 2 по Y<br>
    <b>rotate(xdeg)</b> - поворачивает элемент на х градусов<br>
    <b>scale(x)</b> - увеличивает элемент в х раз<br>
    <b>skew(xdeg)</b> - создает перекос элемента на х градусов<br>
    <b>matrix(a, c, d, b, tx, ty)</b> - позволяет изменять размер, наклон и смещение элемента, где 1 начальное значение<br>
    -a - размер по х<br>
    -c - наклон по у<br>
    -d - наклон по x<br>
    -b - размер по у<br>
    -tx - смещение по х<br>
    -ty - смещение по y`
  ],
  [
    `transition`,
    `задает скорость анимации и свойство к которому оно применяется<br>
    : 1s all - 1 секунда для всех свойств`
  ],
  [
    `columns`,
    `Короткая запись свойств разбиения текста на колонки:<br>
    <b>columns-count</b> - количество колонок<br>
    <b>columns-gap</b> - отступ между колонками<br>
    <b>columns-rule</b> - стилизация разделительной полосы между колонками`
  ],
  [
    `transform-origin`,
    `Позволяет указать относительно какого места производить трансформацию. По умолчанию center`
  ],
  [
    `white-space`,
    `форматирование текста. По default normal(обрезает пробелы и отступы).<br>
    : pre - оставляет текст в оригинальном форматировании`
  ],
  [
    `padding`,
    `Устанавливает отступы внутри элемента.
    <hr>
    Если у элемента нет соседей сверху и слева, то для того чтобы его пододвинуть родительскому контейнеру
    задается отступ (*-left, *-top).`
  ],
  [
    `z-index`,
    `Позиционирует элемент относительно оси z. По дефолту - 0. Работает только с absolute/relative.`
  ],
  [
    `border-box`,
    `box-sizing - при использовании отступов или border размер элемента не изменяется.`
  ],
  [
    `border-collapse`,
    `Указывает как отображать рамки соседних элементов<br>collapse - рамки будут схлопнуты как если бы это была цельная таблица<br>separate - у каждого элемента будет рамка и между ними будут отступы заданные border-spacing`
  ],
  [
    `@font-face`,
    `Подключение сторонего шрифта:<br>
    font-family: 'имя' - имя шрифта<br>
    src: local('имя') - сначала ищет на локальной машине<br>
    src: url(путь) - если на локальной не найдено то берет с Url.<br>
    font-display: swap - указывает что шрифт грузится асинхронно и пока он не подгружен будет применен стандартный шрифт<br>`
  ],
  [
    `Семантические теги`,
    `предназначены для поисковиков и скринридеров`
  ],
  [
    `БЭМ`,
    `блок + модель + модификатор - позволяет создавать блоки для дальнейшего переиспользования.
    <br>
    блокам не задают отступы
    <br>
    элемент - составная часть блока (class="блок-1__имя-элемента"). Элемент всегда часть блока а не другого элемента.
    <br>
    Модификатор - изменяет состояние элемента (class="блок__элемент-модификатор")`
  ],
  [
    `Шрифты`,
    `с засечками - serif, без засечек sans-serif`
  ],
  [
    `Выборка по тегу с частью значения`,
    `<b>[class^="some-"] {}</b> - такая запись позволяет выбрать все элементы с классом начинающимся с "some-"<br>
    ^ - начинающиеся с указанной строки<br>
    $ - кончающиеся<br>
    * - указанная строка является частью полного значения атрибута`
  ],
  [
    `background-clip`,
    `Свойство позволяет указать поведение фонового изображения<br>
    1. <b>border-box</b> - фон будет отображаться во всей блочной модели элемента<br>
    2. <b>padding-box</b> - фон будет отображаться только в content и paddign зонах<br>
    3. <b>content-box</b> - только в контентной зоне<br>
    4. <b>text</b> - фон будет отображаться только под текстом. Но для этого необходимо следующее<pre>
p {
color: transparent;
background-image: linear-gradient(to right, red, black);
background-clip: text;
}</pre>`
  ],
  [
    `float: left/right;`,
    `Свойство позволяет указать что все последующие элементы будут обтекать текущий элемент. Если указанно значение left то сам элемент прижмется к левой части а все что за ним обтекут его по правой стороне и наоборот. Сам блок становится display: block но по ширине ужимается до контента<br>
    Элемент с этим свойством не влияет на высоту родительского элемента, поэтому он может схлопнуться. Чтобы избежать этого есть 2 варианта:<br>
    1. Добавить следующие св-ва родителю - <pre>
::after {
content: "";
display: table;
clear: both;
}</pre> Но этот вариант не лучший т.к. добавляет еще 1 элемент в разметку<br>
2. Установить родителю свойство overflow: hidden`
  ],
  [
    `backface-visibility`,
    `Свойство позволяет указать будет ли видна задняя часть элемента к примеру при развороте. В случае visible задняя сторона будет зеркальным отражением, в случае hidden сторона будет скрыта<br>
    Также это свойство помогает избавиться от бага когда при использовании анимации элемент начинает трястись. В таком случае необходимо родительскому элементу анимируемого добавить это свойство в значении hidden`
  ],
  [
    `outline-offset`,
    `Свойство устанавливает отступ между outline и border`
  ],
  [
    `:nth-child(2n)`,
    `Псевдокласс позволяет задать свойста для каждого 2 элемента`
  ],
  [
    `animation-fill-mode: backwards`,
    `При использовании анимации это свойство применяет к элементу свойства начального состояния анимации, тем самым позволяя нормально использовать задержку анимации`
  ],
  [
    `position`,
    `relative - позволяет позиционировать относительно своего места при этом не выбивается из общего потока
    тегов.
    <hr>
    absolute - позиционируется от body если родителю не задан relative. При этом превращает элемент в
    строчный и выбивается из общего потока тегов.
    <hr>
    fixed - фиксирует элемент в заданном месте при прокрутке. Превращает в строчный элемент.
    <hr>
    sticky - когда страница прокручивается до такого элемента он становится fixed.`
  ],
  [
    `background-...`,
    `repeat - Повторять или нет изображение в элементе.
    <hr>
    position - позиция фонового изображения. Указывается словестно или в px, где 1 значение left, 2 top.
    <hr>
    size - contain/cover, где 1 увеличивается пока не упрется в высоту, а 2 заполняет во всю ширину но
    обрезается по высоте.
    <hr>
    attachment - поведение при прокрутке страницы
    <hr>
    background: url(...) .. center/size - сокращенная запись где позиция и размер указываются через /.
    <hr>
    image - позволяет указать фон элемента в виде картинки или линейного градиента либо все вместе<br>
    <b>background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(100, 100, 100, 0.5)), url(../img/a.png);</b> - совмещение градиента и фоновой картинки. Порядок положения фонов такой же как и в очереди определения => ниже тот кто определен в конце.
    <hr>
    linear-gradient(угол, цвет1 %перехода, цвет2 %перехода) - линейный градиент где %перехода обозначает
    место в котором 1 цвет переходит во 2.<br>
    radial-gradient(x, y) - круговой градиент где х начальный цвет от центра и у конечный цвет у края круга`
  ],
  [
    `list-style-type`,
    `Установка маркеров для списков (&lt;ol&gt;, &lt;ul&gt;), где none - отключает маркеры.`
  ],
  [
    `hyphens`,
    `Позволяет указать текстовым элементам как переносить слова:<br>
    <b>auto</b> - бразурер автоматически будет делать перенос если это возможно<br>
    <b>manual</b> - позволяет в ручную указать перенос<br>
    <b>none</b> - значение по умолчанию`
  ],
  [
    `linear-gradiend()`,
    `Ф-ция для установки линейного градиента.<br>linear-gradient(x, #000 25%, #666 25% 50%, #fff 75%) - где<br>--1 цвет имеет конечную точку(там где начинается переход во 2)<br>--2 цвет имеет начальную точку там же где и конечная у 1 цвета и поэтому плавного перехода не будет. А также имеет конечную точку на 50% что означает там начнется переход в 3 цвет<br>--3 цвет поскольку является последним то имеет начальную точку в которой заканчивается последний переход.<br>x - это необязательный параметр указывающий направление градиента. По умолчанию он направлен сверху вниз. Может быть:<br>1) xdeg - указан в углах<br>2) xturn - указан в частях от единицы, где 0.25 = 90deg<br>3) to top left - может быть указан явно а также скомбинирован из нескольких направлений`
  ]
];
